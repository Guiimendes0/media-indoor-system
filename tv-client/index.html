<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Media Indoor Player</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        #player-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #media-display, #video-display, #web-display {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border: none;
        }
        
        #youtube-display {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Tela de Autentica√ß√£o */
        #auth-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            flex-direction: column;
            text-align: center;
            padding: 20px;
        }

        .auth-container {
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            width: 90%;
            max-width: 400px;
            color: #333;
        }

        .auth-container h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .auth-container p {
            color: #666;
            margin-bottom: 20px;
        }

        .auth-code-input {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .auth-code-input input {
            flex: 1;
            padding: 15px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 18px;
            text-align: center;
            font-weight: bold;
            letter-spacing: 3px;
        }

        .auth-btn {
            width: 100%;
            padding: 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        .auth-btn:hover {
            background: #2980b9;
        }

        .device-info {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 14px;
        }

        /* Status e controles */
        #status-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
            border: 1px solid #333;
        }
        
        #connection-error {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 100;
            padding: 20px;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 8px;
            z-index: 50;
        }
        
        .countdown {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }

        .debug-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #ccc;
            z-index: 100;
        }

        .sync-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(52, 152, 219, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            z-index: 200;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="player-container">
        <!-- Tela de Autentica√ß√£o -->
 <!-- Na tela de autentica√ß√£o - ADICIONAR BOT√ÉO DE RECARREGAR -->
<div id="auth-screen">
    <div class="auth-container">
        <h1>üîê Ativa√ß√£o do Dispositivo</h1>
        <p>Digite o c√≥digo de 6 d√≠gitos fornecido pelo administrador</p>
        
        <div class="auth-code-input">
            <input type="text" id="authCode" maxlength="6" placeholder="000000" pattern="[0-9]{6}">
        </div>
        
        <button class="auth-btn" onclick="activateDevice()">‚úÖ Ativar Dispositivo</button>
        
        <div class="device-info">
            <strong>IP Detectado:</strong> <span id="detected-ip">Carregando...</span><br>
            <small>Informe este IP ao administrador para obter o c√≥digo</small>
        </div>

        <!-- BOT√ÉO DE RECARREGAR ADICIONADO -->
        <div style="margin-top: 15px;">
            <button class="auth-btn" onclick="location.reload()" style="background: #95a5a6;">
                üîÑ Recarregar P√°gina
            </button>
        </div>

        <div id="auth-error" style="color: #e74c3c; margin-top: 15px; display: none;"></div>
    </div>
</div>
        
        <!-- Tela de Erro -->
        <div id="connection-error" class="hidden">
            <h1 style="color: #e74c3c; margin-bottom: 20px; font-size: 2rem;">‚ùå Erro de Conex√£o</h1>
            <p style="font-size: 1.2rem; margin-bottom: 10px;" id="error-message">Erro ao conectar com o servidor</p>
            <button onclick="location.reload()" style="padding: 10px 20px; margin-top: 20px; font-size: 16px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer;">
                üîÑ Tentar Novamente
            </button>
        </div>
        
        <!-- Loading -->
        <div class="loading hidden" id="loading">üîÑ Carregando...</div>

        <!-- Notifica√ß√£o de Sincroniza√ß√£o -->
        <div class="sync-notification hidden" id="syncNotification">
            üîÑ Sincronizando...
        </div>
        
        <!-- M√≠dias -->
        <img id="media-display" class="hidden" alt="M√≠dia">
        <video id="video-display" class="hidden" loop></video>
        <iframe id="youtube-display" class="hidden" allowfullscreen></iframe>
        <iframe id="web-display" class="hidden" allowfullscreen></iframe>
        
        <!-- Status -->
        <div id="status-overlay" class="hidden">
            <div style="margin-bottom: 5px;">‚úÖ <strong id="device-name">-</strong></div>
            <div style="margin-bottom: 5px;">üé¨ <span id="current-media">-</span></div>
            <div style="margin-bottom: 5px;">‚è±Ô∏è <span id="media-time">-</span></div>
            <div>üîó <span id="ws-status">Desconectado</span></div>
        </div>
        
        <!-- Countdown -->
        <div class="countdown hidden" id="countdown">
            Pr√≥xima m√≠dia em: <span id="countdown-timer">0</span>s
        </div>
        
        <!-- Debug -->
        <div class="debug-panel hidden" id="debug-panel">
            <div>Media Indoor Player</div>
            <div id="debug-info">Conectando...</div>
        </div>
    </div>

    <script>
        class MediaPlayer {
            constructor() {
                this.serverUrl = window.location.origin;
                this.wsUrl = `ws://${window.location.host}`;
                this.currentMediaIndex = 0;
                this.mediaList = [];
                this.deviceInfo = null;
                this.updateInterval = 30000;
                this.currentTimeout = null;
                this.currentCountdown = null;
                this.clientIp = null;
                this.currentMedia = null;
                this.ws = null;
                this.deviceId = null;
                this.isSyncing = false;
                this.mediaStartTime = null;
                this.isPlaying = false;
                this.reconnectAttempts = 0;
                
                // Elementos DOM
                this.authScreen = document.getElementById('auth-screen');
                this.connectionError = document.getElementById('connection-error');
                this.errorMessage = document.getElementById('error-message');
                this.loadingElement = document.getElementById('loading');
                this.statusOverlay = document.getElementById('status-overlay');
                this.deviceNameElement = document.getElementById('device-name');
                this.currentMediaElement = document.getElementById('current-media');
                this.mediaTimeElement = document.getElementById('media-time');
                this.wsStatusElement = document.getElementById('ws-status');
                this.debugInfo = document.getElementById('debug-info');
                this.debugPanel = document.getElementById('debug-panel');
                this.countdownElement = document.getElementById('countdown');
                this.countdownTimer = document.getElementById('countdown-timer');
                this.detectedIpElement = document.getElementById('detected-ip');
                this.authCodeInput = document.getElementById('authCode');
                this.authError = document.getElementById('auth-error');
                this.syncNotification = document.getElementById('sync-notification');
                
                // Elementos de m√≠dia
                this.mediaDisplay = document.getElementById('media-display');
                this.videoDisplay = document.getElementById('video-display');
                this.youtubeDisplay = document.getElementById('youtube-display');
                this.webDisplay = document.getElementById('web-display');

                this.lastSyncTime = 0;
                this.syncCooldown = 5000; // 5 segundos entre sincroniza√ß√µes
                this.isProcessingSync = false;
                
                this.init();
            }
            
async init() {
    console.log('üé¨ Iniciando Media Indoor Player...');
    
    // Detectar IP primeiro
    await this.detectClientIp();
    console.log(`üìä IP final para ativa√ß√£o: ${this.clientIp}`);
    
    // Verificar status do dispositivo
    await this.checkDeviceStatus();
}
            
// Dentro da classe MediaPlayer - CORRIGIR detec√ß√£o de IP
async detectClientIp() {
    try {
        console.log('üîç Iniciando detec√ß√£o de IP p√∫blico...');
        
        // PRIMEIRO: Tentar obter IP p√∫blico via servi√ßo externo
        console.log('üåê Obtendo IP p√∫blico...');
        const response = await fetch('https://api.ipify.org?format=json');
        const data = await response.json();
        this.clientIp = data.ip;
        this.detectedIpElement.textContent = `${data.ip} (P√∫blico)`;
        console.log(`üåê IP P√∫blico detectado: ${data.ip}`);
        
    } catch (error) {
        console.error('‚ùå Erro na detec√ß√£o de IP p√∫blico:', error);
        
        // FALLBACK: Tentar m√©todos alternativos
        try {
            // Tentativa com servi√ßo alternativo
            const altResponse = await fetch('https://api64.ipify.org?format=json');
            const altData = await altResponse.json();
            this.clientIp = altData.ip;
            this.detectedIpElement.textContent = `${altData.ip} (P√∫blico - Alternativo)`;
            console.log(`üåê IP P√∫blico alternativo: ${altData.ip}`);
        } catch (fallbackError) {
            console.error('‚ùå Todos os m√©todos de IP p√∫blico falharam:', fallbackError);
            
            // √öLTIMO FALLBACK: Usar hostname do servidor
            const hostname = window.location.hostname;
            if (hostname && hostname !== 'localhost' && hostname !== '127.0.0.1') {
                this.clientIp = hostname;
                this.detectedIpElement.textContent = `${hostname} (Hostname)`;
                console.log(`üåê Usando hostname: ${hostname}`);
            } else {
                this.clientIp = 'N√£o detectado';
                this.detectedIpElement.textContent = 'N√£o detectado - Recarregue a p√°gina';
                console.log('‚ùå IP n√£o detectado');
            }
        }
    }
}

// Nova fun√ß√£o alternativa para detectar IP local
getAlternativeLocalIp() {
    return new Promise((resolve) => {
        try {
            // M√©todo alternativo: tentar atrav√©s de WebRTC simplificado
            const pc = new RTCPeerConnection({ iceServers: [] });
            let localIp = null;
            
            pc.createDataChannel('');
            pc.createOffer()
                .then(offer => pc.setLocalDescription(offer))
                .catch(err => {
                    console.log('Erro no offer:', err);
                    resolve(null);
                });

            pc.onicecandidate = (ice) => {
                if (ice && ice.candidate && ice.candidate.candidate) {
                    const candidate = ice.candidate.candidate;
                    // Procurar por IP IPv4
                    const ipRegex = /([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})/;
                    const match = candidate.match(ipRegex);
                    
                    if (match) {
                        const ip = match[1];
                        // Verificar se √© IP local
                        if (ip.startsWith('192.168.') || 
                            ip.startsWith('10.') || 
                            (ip.startsWith('172.') && this.isPrivateIP(ip))) {
                            localIp = ip;
                            console.log(`üîç IP Local encontrado: ${ip}`);
                        }
                    }
                } else {
                    // N√£o h√° mais candidates
                    pc.close();
                    resolve(localIp || null);
                }
            };

            setTimeout(() => {
                pc.close();
                resolve(localIp || null);
            }, 2000);

        } catch (error) {
            console.log('M√©todo alternativo falhou:', error);
            resolve(null);
        }
    });
}

// Fun√ß√£o auxiliar para verificar IP privado
isPrivateIP(ip) {
    if (ip.startsWith('172.')) {
        const parts = ip.split('.');
        const second = parseInt(parts[1]);
        return second >= 16 && second <= 31;
    }
    return false;
}

// Fun√ß√£o original getLocalIp corrigida
getLocalIp() {
    return new Promise((resolve) => {
        try {
            const RTCPeerConnection = window.RTCPeerConnection || 
                                    window.mozRTCPeerConnection || 
                                    window.webkitRTCPeerConnection;

            if (!RTCPeerConnection) {
                resolve(null);
                return;
            }

            const pc = new RTCPeerConnection({ iceServers: [] });
            let localIp = null;

            pc.createDataChannel('');
            
            pc.createOffer()
                .then(offer => pc.setLocalDescription(offer))
                .catch(err => {
                    console.log('Erro ao criar offer:', err);
                    resolve(null);
                });

            pc.onicecandidate = (ice) => {
                if (!ice.candidate) {
                    // Fim dos candidates
                    pc.close();
                    resolve(localIp);
                    return;
                }
                
                const candidate = ice.candidate.candidate;
                const regex = /([0-9]{1,3}(\.[0-9]{1,3}){3})/;
                const match = regex.exec(candidate);
                
                if (match) {
                    const ip = match[1];
                    // Filtrar apenas IPs IPv4 privados
                    if ((ip.startsWith('192.168.') || 
                         ip.startsWith('10.') || 
                         (ip.startsWith('172.') && this.isPrivateIP(ip))) &&
                         ip !== '0.0.0.0') {
                        
                        localIp = ip;
                        console.log(`üéØ IP Local v√°lido encontrado: ${ip}`);
                    }
                }
            };

            setTimeout(() => {
                pc.close();
                resolve(localIp);
            }, 3000);

        } catch (error) {
            console.error('Erro no getLocalIp:', error);
            resolve(null);
        }
    });
}
       // Fun√ß√£o fallback para detectar IP
getFallbackIp() {
    return new Promise((resolve) => {
        // Tentar obter do URL se estiver em servidor local
        const hostname = window.location.hostname;
        
        if (hostname && hostname !== 'localhost' && hostname !== '127.0.0.1') {
            // Se estiver em um servidor com hostname, usar isso
            resolve(hostname);
            return;
        }
        
        // √öltimo fallback
        resolve('N√£o detectado');
    });
}     
// No m√©todo checkDeviceStatus - MELHORAR tratamento de erro
async checkDeviceStatus() {
    try {
        this.showLoading('Verificando status do dispositivo...');
        console.log(`üîç Verificando status para IP: ${this.clientIp}`);
        
        const response = await fetch(`${this.serverUrl}/api/client/device`);
        
        if (response.ok) {
            this.deviceInfo = await response.json();
            this.deviceId = this.deviceInfo.id;
            console.log('‚úÖ Dispositivo ativo:', this.deviceInfo);
            this.connectWebSocket();
            this.startPlayback();
        } else if (response.status === 403) {
            const errorData = await response.json();
            console.log('üîê Dispositivo n√£o autorizado:', errorData);
            
            // CORRIGIR: Chamar a fun√ß√£o correta
            this.showAuthScreen(); // Esta fun√ß√£o existe na classe
            
        } else {
            throw new Error('Erro ao verificar status');
        }
    } catch (error) {
        console.error('‚ùå Erro ao verificar status:', error);
        // CORRIGIR: Usar a fun√ß√£o correta para mostrar erro
        this.showErrorScreen('Erro de conex√£o com o servidor: ' + error.message);
    }
}
            
showAuthScreen() {
    console.log('üéØ Mostrando tela de autentica√ß√£o...');
    this.authScreen.classList.remove('hidden');
    this.connectionError.classList.add('hidden');
    this.statusOverlay.classList.add('hidden');
    this.hideLoading();
}


// Conectar WebSocket - CORRIGIDO para melhor reconex√£o
connectWebSocket() {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}`;
    
    console.log(`üîó Conectando WebSocket: ${wsUrl}`);
    
    this.ws = new WebSocket(wsUrl);
    
    this.ws.onopen = () => {
        console.log('‚úÖ WebSocket conectado com sucesso');
        this.reconnectAttempts = 0; // Resetar tentativas
        this.wsStatusElement.textContent = 'Conectado';
        this.wsStatusElement.style.color = '#27ae60';
        
        // Registrar dispositivo IMEDIATAMENTE
        if (this.deviceId) {
            this.ws.send(JSON.stringify({
                type: 'register',
                deviceId: this.deviceId,
                ip: this.clientIp,
                timestamp: Date.now()
            }));
            console.log(`üì± Dispositivo ${this.deviceId} registrado no WebSocket`);
        }
        
        // Iniciar heartbeat OTIMIZADO
        setInterval(() => {
            if (this.ws.readyState === WebSocket.OPEN && this.deviceId) {
                this.ws.send(JSON.stringify({
                    type: 'ping',
                    deviceId: this.deviceId,
                    timestamp: Date.now()
                }));
            }
        }, 25000); // A cada 25 segundos
    };
    
    this.ws.onmessage = (event) => {
        try {
            const data = JSON.parse(event.data);
            console.log('üì® Mensagem WebSocket recebida:', data.type);
            this.handleWebSocketMessage(data);
        } catch (error) {
            console.error('‚ùå Erro ao processar mensagem WebSocket:', error);
        }
    };
    
    this.ws.onclose = (event) => {
        console.log(`üîå WebSocket desconectado: C√≥digo ${event.code}, Raz√£o: ${event.reason}`);
        this.wsStatusElement.textContent = 'Desconectado';
        this.wsStatusElement.style.color = '#e74c3c';
        
        // Tentar reconectar com backoff exponencial
        const reconnectDelay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
        console.log(`üîÑ Tentando reconectar em ${reconnectDelay}ms...`);
        
        setTimeout(() => {
            this.reconnectAttempts = this.reconnectAttempts + 1;
            this.connectWebSocket();
        }, reconnectDelay);
    };
    
    this.ws.onerror = (error) => {
        console.error('‚ùå Erro WebSocket:', error);
        this.wsStatusElement.textContent = 'Erro';
        this.wsStatusElement.style.color = '#e74c3c';
    };
}

// 3. handleWebSocketMessage() - Substituir toda a fun√ß√£o atual por:
handleWebSocketMessage(data) {
    console.log('üì® Mensagem WebSocket:', data.type, data);
    
    switch(data.type) {
        case 'sync_command':
            console.log('üîÑüîÑüîÑ COMANDO DE SINCRONIZA√á√ÉO RECEBIDO üîÑüîÑüîÑ', data);
            this.handleSyncCommand(data);
            break;
        case 'announcement':
            console.log('üì¢ Pronunciamento recebido:', data);
            this.handleAnnouncement(data);
            break;
        case 'announcement_cancelled':
            console.log('‚ùå Pronunciamento cancelado:', data);
            this.handleAnnouncementCancelled(data);
            break;
        case 'send_preview':
            console.log('üì∏ Preview solicitado');
            this.sendCurrentMedia();
            break;
    }
}

handleSyncCommand(data) {
    const now = Date.now();
    
    // Verificar se j√° estamos processando uma sync ou se √© muito recente
    if (this.isProcessingSync || (now - this.lastSyncTime < this.syncCooldown)) {
        console.log('‚è∏Ô∏è  Sync ignorada - muito recente ou j√° em processamento');
        return;
    }
    
    console.log('üîÑüîÑüîÑ COMANDO DE SINCRONIZA√á√ÉO RECEBIDO üîÑüîÑüîÑ', data);
    
    this.isProcessingSync = true;
    this.lastSyncTime = now;
    
    // PARAR tudo e aplicar sincroniza√ß√£o IMEDIATAMENTE
    this.clearTimers();
    this.stopAllMedia();
    
    this.syncData = {
        currentMediaIndex: data.currentMediaIndex || 0,
        mediaStartTime: new Date(data.mediaStartTime),
        syncTime: new Date(data.syncTime),
        totalPlaylistDuration: data.totalPlaylistDuration,
        currentMediaDuration: data.currentMediaDuration,
        remainingTime: data.remainingTime,
        elapsedPlaylistTime: data.elapsedPlaylistTime,
        serverTime: data.serverTime
    };
    
    console.log('üéØ Aplicando sincroniza√ß√£o IMEDIATA:', this.syncData);
    
    // Aplicar sincroniza√ß√£o IMEDIATAMENTE
    this.applySync();
    
    // Liberar para pr√≥xima sync ap√≥s um delay
    setTimeout(() => {
        this.isProcessingSync = false;
    }, 1000);
}

// 5. applySync() - Se j√° existir, substituir. Se n√£o existir, adicionar:
applySync() {
    console.log('üéØ Aplicando sincroniza√ß√£o completa:', this.syncData);
    
    this.clearTimers();
    this.stopAllMedia();
    
    // Usar TODOS os par√¢metros da sincroniza√ß√£o
    this.currentMediaIndex = this.syncData.currentMediaIndex || 0;
    this.mediaStartTime = new Date(this.syncData.mediaStartTime);
    this.syncTime = new Date(this.syncData.syncTime);
    this.totalPlaylistDuration = this.syncData.totalPlaylistDuration || 0;
    
    // C√ÅLCULO DE TEMPO OTIMIZADO - usar serverTime se dispon√≠vel
    const now = Date.now();
    const serverTime = this.syncData.serverTime || now;
    const clientTime = now;
    
    // Calcular diferen√ßa entre servidor e cliente (lat√™ncia de rede)
    const networkLatency = clientTime - serverTime;
    console.log(`üì° Lat√™ncia de rede: ${networkLatency}ms`);
    
    // Ajustar o tempo considerando a lat√™ncia
    const adjustedNow = now - networkLatency;
    const elapsedSinceSync = adjustedNow - this.syncTime.getTime();
    
    console.log(`‚è∞ Tempo desde sincroniza√ß√£o (ajustado): ${elapsedSinceSync}ms`);
    
    let remainingTime = this.syncData.remainingTime || 0;
    let currentMediaDuration = this.syncData.currentMediaDuration || 0;
    
    // Se temos tempo decorrido, ajustar o tempo restante COM PRECIS√ÉO
    if (elapsedSinceSync > 0 && currentMediaDuration > 0) {
        remainingTime = Math.max(0, currentMediaDuration - elapsedSinceSync);
        console.log(`‚è±Ô∏è Tempo restante ajustado: ${remainingTime}ms (${elapsedSinceSync}ms decorridos)`);
    }
    
    console.log(`üìä Sincroniza√ß√£o OTIMIZADA: M√≠dia ${this.currentMediaIndex}, ${remainingTime}ms restantes, Dura√ß√£o: ${currentMediaDuration}ms`);
    
    if (this.mediaList.length > 0 && this.currentMediaIndex < this.mediaList.length) {
        const media = this.mediaList[this.currentMediaIndex];
        this.playMediaWithExactSync(media, remainingTime, currentMediaDuration);
    } else {
        console.log('‚ùå √çndice de m√≠dia inv√°lido, reiniciando...');
        this.currentMediaIndex = 0;
        this.playNextMedia();
    }
    
    this.isSyncing = false;
}

// Nova fun√ß√£o para sincroniza√ß√£o exata - OTIMIZADA
playMediaWithExactSync(media, remainingTime, mediaDuration) {
    this.currentMedia = media;
    this.stopAllMedia();
    
    const remainingSeconds = Math.round(remainingTime / 1000);
    const totalSeconds = Math.round(mediaDuration / 1000);
    
    this.currentMediaElement.textContent = media.originalName;
    this.mediaTimeElement.textContent = `${remainingSeconds}s/${totalSeconds}s`;
    this.debugInfo.textContent = `Sincronizado: ${media.originalName} (${remainingSeconds}s)`;
    
    console.log(`üé¨ Reproduzindo m√≠dia sincronizada: ${media.originalName}, ${remainingSeconds}s restantes de ${totalSeconds}s totais`);
    
    // Programar pr√≥xima m√≠dia com o tempo EXATO - OTIMIZADO
    this.currentTimeout = setTimeout(() => {
        console.log('‚è∞ Timer da m√≠dia atual finalizado, indo para pr√≥xima...');
        this.playNextMedia();
    }, remainingTime);
    
    // Iniciar countdown
    this.startCountdown(remainingTime);
    
    // Enviar informa√ß√£o da m√≠dia atual
    this.sendCurrentMedia();
    
    // Reproduzir a m√≠dia baseada no tipo - INICIAR IMEDIATAMENTE
    this.playMediaByType(media, mediaDuration - remainingTime);
}
            
            playMediaWithRemainingTime(media, remainingTimeMs) {
                this.currentMedia = media;
                this.stopAllMedia();
                
                const remainingSeconds = Math.round(remainingTimeMs / 1000);
                
                this.currentMediaElement.textContent = media.originalName;
                this.mediaTimeElement.textContent = `${remainingSeconds}s`;
                this.debugInfo.textContent = `Sincronizado: ${media.originalName} (${remainingSeconds}s)`;
                
                console.log(`üé¨ Reproduzindo m√≠dia sincronizada: ${media.originalName}, ${remainingSeconds}s restantes`);
                
                // Programar pr√≥xima m√≠dia com o tempo restante
                this.currentTimeout = setTimeout(() => {
                    this.playNextMedia();
                }, remainingTimeMs);
                
                // Iniciar countdown
                this.startCountdown(remainingTimeMs);
                
                // Enviar informa√ß√£o da m√≠dia atual
                this.sendCurrentMedia();
                
                // Reproduzir a m√≠dia baseada no tipo
                this.playMediaByType(media, remainingTimeMs);
            }
            
            playMediaByType(media, remainingTimeMs) {
                const totalDuration = (media.displayTime || 10) * 1000;
                const elapsedTime = totalDuration - remainingTimeMs;
                
                switch(media.mediaType) {
                    case 'upload':
                        if (media.type === 'image') {
                            this.playUploadedImage(media);
                        } else {
                            this.playUploadedVideo(media, elapsedTime);
                        }
                        break;
                    case 'youtube':
                        this.playYouTube(media, elapsedTime);
                        break;
                    case 'website':
                        this.playWebsite(media);
                        break;
                    default:
                        console.warn('Tipo de m√≠dia n√£o suportado:', media.mediaType);
                        setTimeout(() => this.playNextMedia(), 2000);
                }
            }
            
            handleAnnouncement(data) {
                console.log('üì¢ Anunciamento recebido:', data.announcement.name);
                
                this.clearTimers();
                this.stopAllMedia();
                
                // Reproduzir o anunciamento
                this.playMedia(data.media, true);
                
                // Programar retorno √† programa√ß√£o normal
                setTimeout(() => {
                    this.loadMediaList(true);
                }, data.announcement.displayTime * 1000);
            }
            
            handleAnnouncementCancelled(data) {
                console.log('üõë Anunciamento cancelado');
                this.loadMediaList(true);
            }
            
            showSyncNotification() {
                this.syncNotification.classList.remove('hidden');
                setTimeout(() => {
                    this.syncNotification.classList.add('hidden');
                }, 3000);
            }
            
// Corrigir a fun√ß√£o sendCurrentMedia para enviar menos frequentemente:
sendCurrentMedia() {
    // Verificar se podemos enviar (evitar spam) - AUMENTAR o intervalo
    const now = Date.now();
    if (now - (this.lastMediaUpdate || 0) < 10000) { // 10 segundos entre updates (era 2)
        return;
    }
    
    if (this.ws && this.ws.readyState === WebSocket.OPEN && this.currentMedia) {
        const mediaDuration = (this.currentMedia.displayTime || 10) * 1000;
        
        let elapsed = 0;
        let remainingTime = mediaDuration;
        
        if (this.mediaStartTime) {
            elapsed = now - this.mediaStartTime.getTime();
            remainingTime = Math.max(0, mediaDuration - elapsed);
        }
        
        const mediaInfo = {
            type: 'current_media',
            deviceId: this.deviceId,
            media: this.currentMedia,
            currentMediaIndex: this.currentMediaIndex,
            mediaStartTime: this.mediaStartTime ? this.mediaStartTime.toISOString() : new Date().toISOString(),
            syncTime: this.syncTime ? this.syncTime.toISOString() : null,
            remainingTime: remainingTime,
            mediaDuration: mediaDuration,
            elapsed: elapsed,
            timestamp: new Date()
        };
        
        this.ws.send(JSON.stringify(mediaInfo));
        this.lastMediaUpdate = now;
        
        console.log('üì§ Enviando update de m√≠dia:', {
            media: this.currentMedia.originalName,
            remainingTime: Math.round(remainingTime / 1000) + 's'
        });
    }
}
            
// Fun√ß√£o de ativa√ß√£o do dispositivo - CORRIGIDA
async activateDevice() {
    const authCode = this.authCodeInput.value.trim();
    
    if (authCode.length !== 6 || !/^\d+$/.test(authCode)) {
        this.showAuthError('C√≥digo inv√°lido. Digite 6 n√∫meros.');
        return;
    }

    try {
        this.showLoading('Ativando dispositivo...');
        
        console.log(`üîê Tentando ativar com IP: ${this.clientIp}, C√≥digo: ${authCode}`);
        
        const response = await fetch(`${this.serverUrl}/api/devices/activate`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                ip: this.clientIp,
                authCode: authCode
            })
        });
        
        if (response.ok) {
            const result = await response.json();
            console.log('‚úÖ Dispositivo ativado com sucesso:', result);
            
            // MOSTRAR MENSAGEM DE SUCESSO ANTES DE CONTINUAR
            this.showLoading('‚úÖ Dispositivo ativado! Conectando...');
            
            // Esperar um pouco para mostrar a mensagem de sucesso
            setTimeout(() => {
                this.hideAuthScreen();
                this.checkDeviceStatus();
            }, 2000);
            
        } else {
            const error = await response.json();
            console.error('‚ùå Erro na ativa√ß√£o:', error);
            throw new Error(error.error || 'C√≥digo inv√°lido');
        }
    } catch (error) {
        console.error('‚ùå Erro na ativa√ß√£o:', error);
        this.showAuthError(error.message);
    }
}

// Corrigir a fun√ß√£o hideAuthScreen
hideAuthScreen() {
    console.log('üéØ Ocultando tela de autentica√ß√£o...');
    this.authScreen.classList.add('hidden');
    this.authError.style.display = 'none';
    this.hideLoading();
}

// Corrigir a fun√ß√£o showAuthError
showAuthError(message) {
    this.authError.textContent = message;
    this.authError.style.display = 'block';
    this.hideLoading();
    console.log('‚ùå Erro de autentica√ß√£o:', message);
}
            
            showAuthError(message) {
                this.authError.textContent = message;
                this.authError.style.display = 'block';
                this.hideLoading();
            }
            
            async startPlayback() {
                this.hideAuthScreen();
                this.connectionError.classList.add('hidden');
                this.statusOverlay.classList.remove('hidden');
                this.debugPanel.classList.remove('hidden');
                
                this.deviceNameElement.textContent = this.deviceInfo.name;
                this.debugInfo.textContent = `Conectado: ${this.deviceInfo.name}`;
                
                // Iniciar com tempo atual
                this.mediaStartTime = new Date();
                
                await this.loadMediaList();
            }
            
            async loadMediaList(forceRestart = false) {
                try {
                    this.showLoading('Carregando conte√∫do...');
                    
                    const response = await fetch(`${this.serverUrl}/api/client/media`);
                    
                    if (response.ok) {
                        const newMediaList = await response.json();
                        const mediaChanged = JSON.stringify(newMediaList) !== JSON.stringify(this.mediaList);
                        
                        this.mediaList = newMediaList;
                        console.log(`üìã ${this.mediaList.length} m√≠dia(s) carregada(s)`);
                        
                        if (this.mediaList.length > 0) {
                            this.hideLoading();
                            
                            if (forceRestart || mediaChanged || this.currentMediaIndex >= this.mediaList.length) {
                                this.currentMediaIndex = 0;
                                this.mediaStartTime = new Date();
                                this.playNextMedia();
                            } else if (!this.isSyncing) {
                                // Continuar de onde parou
                                this.playNextMedia();
                            }
                        } else {
                            this.showLoading('‚ö†Ô∏è Nenhum conte√∫do dispon√≠vel');
                        }
                    } else {
                        throw new Error('Erro ao carregar conte√∫do');
                    }
                } catch (error) {
                    console.error('‚ùå Erro ao carregar m√≠dias:', error);
                    this.showErrorScreen('Erro ao carregar conte√∫do');
                }
            }
            
playNextMedia() {
    if (this.mediaList.length === 0) {
        console.log('‚ùå Nenhuma m√≠dia para reproduzir');
        return;
    }
    
    this.clearTimers();
    
    // Se chegou ao final da playlist, voltar ao in√≠cio
    if (this.currentMediaIndex >= this.mediaList.length) {
        this.currentMediaIndex = 0;
        console.log('üîÑ Fim da playlist, reiniciando...');
    }
    
    const media = this.mediaList[this.currentMediaIndex];
    const mediaDuration = (media.displayTime || 10) * 1000;
    
    console.log(`üé¨ Reproduzindo m√≠dia ${this.currentMediaIndex + 1}/${this.mediaList.length}: ${media.originalName} por ${mediaDuration}ms`);
    
    // Se estamos em modo sincronizado, usar tempo exato
    if (this.syncTime) {
        const now = Date.now();
        const syncElapsed = now - this.syncTime.getTime();
        const playlistPosition = syncElapsed % this.totalPlaylistDuration;
        
        // Recalcular em qual m√≠dia estamos baseado no tempo total da playlist
        this.recalculateMediaIndexFromSync(playlistPosition);
        
        // Recalcular tempo restante - CORRE√á√ÉO: usar tempo REAL decorrido
        const mediaStartTime = this.calculateMediaStartTime(this.currentMediaIndex);
        const mediaElapsed = now - mediaStartTime;
        const remainingTime = Math.max(0, mediaDuration - mediaElapsed);
        
        console.log(`üîÑ Recalculando sincroniza√ß√£o: Posi√ß√£o ${playlistPosition}ms, M√≠dia ${this.currentMediaIndex}, ${remainingTime}ms restantes`);
        
        this.playMediaWithExactSync(media, remainingTime, mediaDuration);
    } else {
        // Modo normal (n√£o sincronizado)
        this.playMedia(media);
    }
    
    // Avan√ßar √≠ndice para pr√≥xima m√≠dia (ap√≥s c√°lculo de sincroniza√ß√£o)
    this.currentMediaIndex = (this.currentMediaIndex + 1) % this.mediaList.length;
}

// Fun√ß√µes auxiliares para c√°lculo de sincroniza√ß√£o
recalculateMediaIndexFromSync(playlistPosition) {
    let accumulatedTime = 0;
    
    for (let i = 0; i < this.mediaList.length; i++) {
        const media = this.mediaList[i];
        const mediaDuration = (media.displayTime || 10) * 1000;
        
        if (playlistPosition < accumulatedTime + mediaDuration) {
            this.currentMediaIndex = i;
            console.log(`üìä Sincroniza√ß√£o: Posi√ß√£o ${playlistPosition}ms ‚Üí M√≠dia ${i}`);
            return;
        }
        
        accumulatedTime += mediaDuration;
    }
    
    // Se passou de toda a playlist, voltar ao in√≠cio
    this.currentMediaIndex = 0;
}

calculateMediaStartTime(mediaIndex) {
    if (!this.syncTime) return Date.now();
    
    let accumulatedTime = 0;
    
    for (let i = 0; i < mediaIndex; i++) {
        const media = this.mediaList[i];
        accumulatedTime += (media.displayTime || 10) * 1000;
    }
    
    return this.syncTime.getTime() + accumulatedTime;
}
            
            playMedia(media, isAnnouncement = false) {
                this.currentMedia = media;
                this.stopAllMedia();
                
                this.currentMediaElement.textContent = media.originalName;
                this.mediaTimeElement.textContent = `${media.displayTime}s`;
                this.debugInfo.textContent = `Reproduzindo: ${media.originalName} ${isAnnouncement ? '(Anunciamento)' : ''}`;
                
                const displayTime = (media.displayTime || 10) * 1000;
                
                // Atualizar tempo de in√≠cio
                this.mediaStartTime = new Date();
                
                this.startCountdown(displayTime);
                
                this.currentTimeout = setTimeout(() => {
                    if (!isAnnouncement) {
                        this.playNextMedia();
                    }
                }, displayTime);
                
                this.sendCurrentMedia();
                
                // Reproduzir a m√≠dia
                this.playMediaByType(media, 0);
            }
            
            playUploadedImage(media) {
                this.showLoading(`Carregando imagem: ${media.originalName}`);
                
                this.mediaDisplay.onload = () => {
                    console.log('‚úÖ Imagem carregada');
                    this.hideLoading();
                    this.mediaDisplay.classList.remove('hidden');
                };
                
                this.mediaDisplay.onerror = () => {
                    console.error('‚ùå Erro ao carregar imagem');
                    this.hideLoading();
                    setTimeout(() => this.playNextMedia(), 2000);
                };
                
                this.mediaDisplay.src = `${this.serverUrl}${media.path}?t=${Date.now()}`;
            }
            
            playUploadedVideo(media, seekTime = 0) {
                this.showLoading(`Carregando v√≠deo: ${media.originalName}`);
                
                this.videoDisplay.onloadeddata = () => {
                    console.log('‚úÖ V√≠deo carregado');
                    this.hideLoading();
                    this.videoDisplay.classList.remove('hidden');
                    
                    if (seekTime > 0) {
                        const seekSeconds = seekTime / 1000;
                        this.videoDisplay.currentTime = Math.min(seekSeconds, this.videoDisplay.duration - 1);
                        console.log(`‚è© Video seek para: ${seekSeconds}s`);
                    }
                    
                    this.videoDisplay.play().catch(e => {
                        console.error('Erro ao reproduzir v√≠deo:', e);
                        setTimeout(() => this.playNextMedia(), 2000);
                    });
                };
                
                this.videoDisplay.onerror = () => {
                    console.error('‚ùå Erro ao carregar v√≠deo');
                    this.hideLoading();
                    setTimeout(() => this.playNextMedia(), 2000);
                };
                
                this.videoDisplay.onended = () => {
                    console.log('‚è≠Ô∏è V√≠deo finalizado');
                    this.playNextMedia();
                };
                
                this.videoDisplay.src = `${this.serverUrl}${media.path}?t=${Date.now()}`;
            }
            
            playYouTube(media, seekTime = 0) {
                this.showLoading(`Carregando YouTube: ${media.originalName}`);
                
                const videoId = this.extractYouTubeId(media.path);
                if (!videoId) {
                    console.error('‚ùå URL do YouTube inv√°lida');
                    this.hideLoading();
                    setTimeout(() => this.playNextMedia(), 2000);
                    return;
                }
                
                // Calcular tempo de in√≠cio
                let startParam = '';
                if (seekTime > 0) {
                    const startSeconds = Math.floor(seekTime / 1000);
                    startParam = `&start=${startSeconds}`;
                    console.log(`‚è© YouTube start em: ${startSeconds}s`);
                }
                
                const embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1&controls=0&modestbranding=1&rel=0&enablejsapi=1${startParam}`;
                
                this.youtubeDisplay.onload = () => {
                    console.log('‚úÖ YouTube carregado');
                    this.hideLoading();
                    this.youtubeDisplay.classList.remove('hidden');
                };
                
                this.youtubeDisplay.onerror = () => {
                    console.error('‚ùå Erro ao carregar YouTube');
                    this.hideLoading();
                    setTimeout(() => this.playNextMedia(), 2000);
                };
                
                this.youtubeDisplay.src = embedUrl;
            }
            
            playWebsite(media) {
                this.showLoading(`Carregando site: ${media.originalName}`);
                
                this.webDisplay.onload = () => {
                    console.log('‚úÖ Site carregado');
                    this.hideLoading();
                    this.webDisplay.classList.remove('hidden');
                };
                
                this.webDisplay.onerror = () => {
                    console.error('‚ùå Erro ao carregar site');
                    this.hideLoading();
                    setTimeout(() => this.playNextMedia(), 2000);
                };
                
                this.webDisplay.src = media.path;
            }
            
            stopAllMedia() {
                this.mediaDisplay.classList.add('hidden');
                this.videoDisplay.classList.add('hidden');
                this.youtubeDisplay.classList.add('hidden');
                this.webDisplay.classList.add('hidden');
                
                this.videoDisplay.pause();
                this.videoDisplay.currentTime = 0;
                
                // N√£o limpar src para evitar flickering
            }
            
            clearTimers() {
                if (this.currentTimeout) {
                    clearTimeout(this.currentTimeout);
                    this.currentTimeout = null;
                }
                
                if (this.currentCountdown) {
                    clearInterval(this.currentCountdown);
                    this.currentCountdown = null;
                }
                
                this.countdownElement.classList.add('hidden');
            }
            
            extractYouTubeId(url) {
                const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
                const match = url.match(regex) ;
                return match ? match[1] : null;
            }
            
            startCountdown(duration) {
                this.countdownElement.classList.remove('hidden');
                let timeLeft = duration / 1000;
                this.countdownTimer.textContent = Math.round(timeLeft);
                
                this.currentCountdown = setInterval(() => {
                    timeLeft--;
                    this.countdownTimer.textContent = Math.round(timeLeft);
                    
                    if (timeLeft <= 0) {
                        clearInterval(this.currentCountdown);
                        this.countdownElement.classList.add('hidden');
                    }
                }, 1000);
            }
            
            showLoading(message) {
                this.loadingElement.textContent = message;
                this.loadingElement.classList.remove('hidden');
            }
            
            hideLoading() {
                this.loadingElement.classList.add('hidden');
            }
            
showErrorScreen(message) {
    console.log('‚ùå Mostrando tela de erro:', message);
    this.errorMessage.textContent = message;
    this.connectionError.classList.remove('hidden');
    this.statusOverlay.classList.add('hidden');
    this.authScreen.classList.add('hidden');
    this.hideLoading();
    this.clearTimers();
    this.stopAllMedia();
}
        }
        
        let mediaPlayer;
        
        document.addEventListener('DOMContentLoaded', () => {
            mediaPlayer = new MediaPlayer();
            
            document.getElementById('authCode').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    activateDevice();
                }
            });
        });

        function activateDevice() {
            if (mediaPlayer) {
                mediaPlayer.activateDevice();
            }
        }

        document.addEventListener('dragstart', (e) => e.preventDefault());
        
        window.addEventListener('error', (e) => {
            console.error('üö® Erro global:', e.error);
        });
    </script>
</body>
</html>