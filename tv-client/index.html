<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MEDIA STAFF | Player</title>
    <link rel="icon" href="assets/logo.png" type="image/png">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="player-container">
        <!-- Tela de Autentica√ß√£o Atualizada -->
        <div id="auth-screen">
            <div class="auth-container">
                <div class="logo">
                    <img src="assets/logo.png" alt="">
                    <h2>MEDIA STAFF</h2>
                </div>
                <p>Use o c√≥digo abaixo para cadastrar este dispositivo no painel administrativo</p>
                
                <div class="auth-code-display">
                    <div style="color: #666; margin-bottom: 10px;">C√≥digo de Ativa√ß√£o:</div>
                    <div class="auth-code" id="generatedAuthCode">------</div>
                    <div class="code-expiry" id="codeExpiry">Gerando novo c√≥digo...</div>
                </div>
                
                <div class="device-info">
                    <strong>Identificador do Dispositivo:</strong> <span id="device-mac">Carregando...</span><br>
                    <strong>Status:</strong> <span id="device-status">N√£o autenticado</span><br>
                    <small>Este c√≥digo √© v√°lido por 5 minutos. Ap√≥s esse per√≠odo, um novo c√≥digo ser√° gerado automaticamente.</small>
                </div>

                <div id="auth-error" style="color: #e74c3c; margin-top: 15px; display: none;"></div>
            </div>
        </div>
        
        <!-- Tela de Erro -->
        <div id="connection-error" class="hidden">
            <h1 style="color: #e74c3c; margin-bottom: 20px; font-size: 2rem;">‚ùå Erro de Conex√£o</h1>
            <p style="font-size: 1.2rem; margin-bottom: 10px;" id="error-message">Erro ao conectar com o servidor</p>
            <button onclick="location.reload()" style="padding: 10px 20px; margin-top: 20px; font-size: 16px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer;">
                üîÑ Tentar Novamente
            </button>
        </div>
        
        <!-- Loading -->
        <div class="loading hidden" id="loading">üîÑ Carregando...</div>

        <!-- Notifica√ß√£o de Sincroniza√ß√£o -->
        <div class="sync-notification hidden" id="syncNotification">
            üîÑ Sincronizando...
        </div>
        
        <!-- M√≠dias -->
        <img id="media-display" class="hidden" alt="M√≠dia">
        <video id="video-display" class="hidden" loop></video>
        <iframe id="youtube-display" class="hidden" allowfullscreen></iframe>
        <iframe id="web-display" class="hidden" allowfullscreen></iframe>
        
        <!-- Status -->
        <div id="status-overlay" class="hidden">
            <div style="margin-bottom: 5px;">‚úÖ <strong id="device-name">-</strong></div>
            <div style="margin-bottom: 5px;">üé¨ <span id="current-media">-</span></div>
            <div style="margin-bottom: 5px;">‚è±Ô∏è <span id="media-time">-</span></div>
            <div>üîó <span id="ws-status">Desconectado</span></div>
        </div>
        
        <!-- Countdown -->
        <div class="countdown hidden" id="countdown">
            Pr√≥xima m√≠dia em: <span id="countdown-timer">0</span>s
        </div>
        
        <!-- Debug -->
        <div class="debug-panel hidden" id="debug-panel">
            <div>Media Indoor Player</div>
            <div id="debug-info">Conectando...</div>
        </div>
    </div>

<script>
    class MediaPlayer {
        constructor() {
            this.serverUrl = window.location.origin;
            this.wsUrl = `wss://${window.location.host}`;
            this.currentMediaIndex = 0;
            this.mediaList = [];
            this.deviceInfo = null;
            this.currentTimeout = null;
            this.currentCountdown = null;
            this.deviceMac = null;
            this.currentMedia = null;
            this.ws = null;
            this.deviceId = null;
            this.playlistSyncInfo = null;
            this.pendingPlaylistUpdate = null;
            
            // NOVO: Configura√ß√µes do dispositivo
            this.audioEnabled = false;
            this.rotation = 'horizontal';
            
            // Elementos DOM
            this.authScreen = document.getElementById('auth-screen');
            this.connectionError = document.getElementById('connection-error');
            this.errorMessage = document.getElementById('error-message');
            this.loadingElement = document.getElementById('loading');
            this.statusOverlay = document.getElementById('status-overlay');
            this.deviceNameElement = document.getElementById('device-name');
            this.currentMediaElement = document.getElementById('current-media');
            this.mediaTimeElement = document.getElementById('media-time');
            this.wsStatusElement = document.getElementById('ws-status');
            this.debugInfo = document.getElementById('debug-info');
            this.debugPanel = document.getElementById('debug-panel');
            this.countdownElement = document.getElementById('countdown');
            this.countdownTimer = document.getElementById('countdown-timer');
            this.deviceMacElement = document.getElementById('device-mac');
            this.deviceStatusElement = document.getElementById('device-status');
            this.authError = document.getElementById('auth-error');
            this.syncNotification = document.getElementById('syncNotification');
            this.generatedAuthCode = document.getElementById('generatedAuthCode');
            this.codeExpiryElement = document.getElementById('codeExpiry');
            
            // Elementos de m√≠dia
            this.mediaDisplay = document.getElementById('media-display');
            this.videoDisplay = document.getElementById('video-display');
            this.youtubeDisplay = document.getElementById('youtube-display');
            this.webDisplay = document.getElementById('web-display');

            // Controles de estado
            this.isLoadingMedia = false;
            this.playbackLock = false;
            this.lastMediaUpdate = 0;
            this.autoPlayAttempted = false;
            
            this.init();
        }
        
        async init() {
            console.log('üé¨ Iniciando Media Indoor Player...');
            
            await this.generateDeviceMac();
            await this.checkAuthenticationStatus();
            this.startCodeGeneration();
            this.startActivationPolling();
        }

        startActivationPolling() {
            console.log('üîÑ Iniciando verifica√ß√£o peri√≥dica de ativa√ß√£o...');
            
            this.activationInterval = setInterval(async () => {
                if (this.deviceId) {
                    clearInterval(this.activationInterval);
                    return;
                }
                
                try {
                    const response = await fetch(`${this.serverUrl}/api/player/check-activation`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            mac: this.deviceMac
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        if (result.activated && result.device) {
                            console.log('üéâ Dispositivo foi ativado!', result.device);
                            this.deviceId = result.device.id;
                            this.deviceInfo = result.device;
                            
                            // NOVO: Aplicar configura√ß√µes do dispositivo
                            this.audioEnabled = result.device.audioEnabled || false;
                            this.rotation = result.device.rotation || 'horizontal';
                            this.applyDeviceConfig();
                            
                            localStorage.setItem('deviceAuth', JSON.stringify({
                                deviceId: this.deviceId,
                                mac: this.deviceMac,
                                activatedAt: new Date(),
                                audioEnabled: this.audioEnabled,
                                rotation: this.rotation,
                                developer: this.developerMode || false
                            }));
                            
                            if (this.codeGenerationInterval) {
                                clearInterval(this.codeGenerationInterval);
                                this.codeGenerationInterval = null;
                            }
                            
                            this.startPlayback();
                        }
                    }
                } catch (error) {
                    console.log('Verifica√ß√£o de ativa√ß√£o:', error.message);
                }
            }, 5000);
        }

        // NOVO: Aplicar configura√ß√µes do dispositivo
        applyDeviceConfig() {
            console.log('‚öôÔ∏è Aplicando configura√ß√µes do dispositivo:', {
                audioEnabled: this.audioEnabled,
                rotation: this.rotation,
                developer: this.developerMode
            });
            
            // Aplicar configura√ß√£o de √°udio
            if (this.videoDisplay) {
                this.videoDisplay.muted = !this.audioEnabled;
                console.log(`üîä √Åudio ${this.audioEnabled ? 'habilitado' : 'desabilitado'}`);
            }
            
            // Aplicar rota√ß√£o
            this.applyRotation();
            
            // Aplicar developer flag: mostrar/ocultar overlays de debug/status
            this.toggleDeveloperElements();
        }
        
// NOVO: Aplicar rota√ß√£o - CORRIGIDO para funcionar imediatamente
applyRotation() {
    console.log(`üîÑ Aplicando rota√ß√£o: ${this.rotation}`);
    
    const elements = [
        this.mediaDisplay,
        this.videoDisplay,
        this.youtubeDisplay,
        this.webDisplay
    ];
    
    elements.forEach(element => {
        if (element && element.parentElement) {
            // Remover classes de rota√ß√£o anteriores
            element.classList.remove('rotation-horizontal', 'rotation-vertical', 
                                   'rotation-horizontal-inverted', 'rotation-vertical-inverted');
            
            // Adicionar nova classe de rota√ß√£o
            element.classList.add(`rotation-${this.rotation}`);
            
            console.log(`üéØ Rota√ß√£o ${this.rotation} aplicada em`, element.id);
        }
    });
    
    // For√ßar redimensionamento se necess√°rio
    setTimeout(() => {
        window.dispatchEvent(new Event('resize'));
    }, 100);
}
// Fun√ß√£o para aplicar visibilidade dos elementos de developer
toggleDeveloperElements() {
    // buscar os elementos (caso n√£o sejam instanciados como this.*)
    const statusOverlay = document.getElementById('status-overlay');
    const countdownEl = document.getElementById('countdown');
    const debugPanel = document.getElementById('debug-panel');

    if (this.developerMode) {
        if (statusOverlay) statusOverlay.classList.remove('hidden');
        if (countdownEl) countdownEl.classList.remove('hidden');
        if (debugPanel) debugPanel.classList.remove('hidden');
    } else {
        if (statusOverlay) statusOverlay.classList.add('hidden');
        if (countdownEl) countdownEl.classList.add('hidden');
        if (debugPanel) debugPanel.classList.add('hidden');
    }

    // For√ßar redimensionamento se necess√°rio
    setTimeout(() => {
        window.dispatchEvent(new Event('dev'));
    }, 100);
}
        async generateDeviceMac() {
            let savedMac = localStorage.getItem('deviceMac');
            
            if (!savedMac) {
                const macArray = new Uint8Array(6);
                crypto.getRandomValues(macArray);
                savedMac = Array.from(macArray)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join(':')
                    .toUpperCase();
                localStorage.setItem('deviceMac', savedMac);
            }
            
            this.deviceMac = savedMac;
            this.deviceMacElement.textContent = this.deviceMac;
            console.log(`üì± MAC do dispositivo: ${this.deviceMac}`);
        }

        async checkAuthenticationStatus() {
            try {
                const savedAuth = localStorage.getItem('deviceAuth');
                if (savedAuth) {
                    const authData = JSON.parse(savedAuth);
                    this.deviceId = authData.deviceId;
                    
                    // NOVO: Carregar configura√ß√µes salvas
                    this.audioEnabled = authData.audioEnabled || false;
                    this.rotation = authData.rotation || 'horizontal';
                    this.developerMode = authData.developer || false;
                    
                    console.log('üîç Verificando autentica√ß√£o salva:', authData);
                    
                    try {
                        const response = await fetch(`${this.serverUrl}/api/player/device`, {
                            headers: {
                                'x-device-mac': this.deviceMac
                            }
                        });
                        
                        if (response.ok) {
                    this.deviceInfo = await response.json();
                    console.log('‚úÖ Dispositivo j√° autenticado e ativo:', this.deviceInfo);

                    // Se servidor manda configura√ß√µes, sobrepor e aplicar
                    if (this.deviceInfo.audioEnabled !== undefined) {
                        this.audioEnabled = this.deviceInfo.audioEnabled;
                    }
                    if (this.deviceInfo.rotation !== undefined) {
                        this.rotation = this.deviceInfo.rotation;
                    }
                    if (this.deviceInfo.developer !== undefined) {
                        this.developerMode = this.deviceInfo.developer;
                    }

                    this.applyDeviceConfig();

                    this.startPlayback();
                    return;
                        } else if (response.status === 403) {
                            console.log('‚ùå Autentica√ß√£o salva n√£o √© mais v√°lida');
                            localStorage.removeItem('deviceAuth');
                        }
                    } catch (error) {
                        console.error('Erro ao verificar dispositivo:', error);
                    }
                }
                
                this.showAuthScreen();
                
            } catch (error) {
                console.error('‚ùå Erro ao verificar autentica√ß√£o:', error);
                this.showAuthScreen();
            }
        }

        startCodeGeneration() {
            this.generateNewAuthCode();
            
            this.codeGenerationInterval = setInterval(() => {
                this.generateNewAuthCode();
            }, 5 * 60 * 1000);
        }

        generateNewAuthCode() {
            this.authCode = Math.floor(100000 + Math.random() * 900000).toString();
            this.codeExpiry = new Date(Date.now() + 5 * 60 * 1000);
            
            this.generatedAuthCode.textContent = this.authCode;
            this.updateCodeExpiryDisplay();
            
            console.log(`üîê Novo c√≥digo gerado: ${this.authCode}`);
            
            this.registerAuthCodeWithServer();
        }

        updateCodeExpiryDisplay() {
            const now = new Date();
            const timeLeft = this.codeExpiry - now;
            
            if (timeLeft <= 0) {
                this.codeExpiryElement.textContent = 'C√≥digo expirado - gerando novo...';
                return;
            }
            
            const minutes = Math.floor(timeLeft / (60 * 1000));
            const seconds = Math.floor((timeLeft % (60 * 1000)) / 1000);
            
            this.codeExpiryElement.textContent = `Expira em: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            setTimeout(() => this.updateCodeExpiryDisplay(), 1000);
        }

        async registerAuthCodeWithServer() {
            try {
                const response = await fetch(`${this.serverUrl}/api/devices/register-code`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        mac: this.deviceMac,
                        authCode: this.authCode,
                        expiry: this.codeExpiry.toISOString()
                    })
                });

                if (response.ok) {
                    console.log('‚úÖ C√≥digo registrado no servidor para MAC:', this.deviceMac);
                } else {
                    console.error('‚ùå Erro ao registrar c√≥digo no servidor');
                }
            } catch (error) {
                console.error('‚ùå Erro de conex√£o ao registrar c√≥digo:', error);
            }
        }

        connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}`;
            
            console.log(`üîó Conectando WebSocket: ${wsUrl}`);
            
            this.ws = new WebSocket(wsUrl);
            
            this.ws.onopen = () => {
                console.log('‚úÖ WebSocket conectado com sucesso');
                this.wsStatusElement.textContent = 'Conectado';
                this.wsStatusElement.style.color = '#27ae60';
                
                if (this.deviceId) {
                    this.ws.send(JSON.stringify({
                        type: 'register',
                        deviceId: this.deviceId,
                        mac: this.deviceMac,
                        timestamp: Date.now()
                    }));
                }
            };
            
            this.ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    console.log('üì® Mensagem WebSocket recebida:', data.type);
                    this.handleWebSocketMessage(data);
                } catch (error) {
                    console.error('‚ùå Erro ao processar mensagem WebSocket:', error);
                }
            };
            
            this.ws.onclose = (event) => {
                console.log(`üîå WebSocket desconectado: C√≥digo ${event.code}, Raz√£o: ${event.reason}`);
                this.wsStatusElement.textContent = 'Desconectado';
                this.wsStatusElement.style.color = '#e74c3c';
                
                setTimeout(() => {
                    this.connectWebSocket();
                }, 5000);
            };
            
            this.ws.onerror = (error) => {
                console.error('‚ùå Erro WebSocket:', error);
                this.wsStatusElement.textContent = 'Erro';
                this.wsStatusElement.style.color = '#e74c3c';
            };
        }

        handleWebSocketMessage(data) {
            console.log('üì® Mensagem WebSocket:', data.type, data);
            
            switch(data.type) {
                case 'sync_command':
                    console.log('üîÑ COMANDO DE SINCRONIZA√á√ÉO RECEBIDO', data);
                    this.handleSyncCommand(data);
                    break;
                case 'announcement':
                    console.log('üì¢ Pronunciamento recebido:', data);
                    this.handleAnnouncement(data);
                    break;
                case 'announcement_cancelled':
                    console.log('‚ùå Pronunciamento cancelado:', data);
                    this.handleAnnouncementCancelled(data);
                    break;
                case 'send_preview':
                    console.log('üì∏ Preview solicitado');
                    this.sendCurrentMedia();
                    break;
                case 'device_disconnected':
                    console.log('üîå Dispositivo desconectado pelo administrador');
                    this.handleDeviceDisconnected(data);
                    break;
                // NOVO: Tratar atualiza√ß√µes de configura√ß√£o
                case 'device_config_update':
                    console.log('‚öôÔ∏è Configura√ß√£o do dispositivo atualizada:', data.config);
                    this.handleDeviceConfigUpdate(data.config);
                    break;
                case 'playlist_updated':
                    console.log('üîÑ Playlist atualizada, recarregando m√≠dias...');
                    this.handlePlaylistUpdated(data);
            break;
            }
        }

// NOVA: Fun√ß√£o de debug para verificar estado
debugPlaylistState() {
    console.log('üêõ DEBUG - Estado da Playlist:');
    console.log('- √çndice atual:', this.currentMediaIndex);
    console.log('- Total de m√≠dias:', this.mediaList.length);
    console.log('- Atualiza√ß√£o pendente:', this.pendingPlaylistUpdate);
    console.log('- M√≠dia atual:', this.currentMedia?.originalName);
    console.log('- Playback lock:', this.playbackLock);
}

// CORRE√á√ÉO: Tratar atualiza√ß√£o de playlist de forma mais agressiva
handlePlaylistUpdated(data) {
    console.log('üîÑ Recebida notifica√ß√£o de atualiza√ß√£o da playlist:', data.playlistId);
    console.log(`üìä Estado atual: √çndice ${this.currentMediaIndex}/${this.mediaList.length}`);
    
    // Mostrar notifica√ß√£o visual
    this.showUpdateNotification();
    
    // Salvar a nova informa√ß√£o da playlist
    this.pendingPlaylistUpdate = {
        playlistId: data.playlistId,
        timestamp: new Date(),
        applied: false
    };
    
    console.log('üìù Atualiza√ß√£o de playlist salva para aplicar');
    
    // SE estamos no in√≠cio ou perto do fim, aplicar imediatamente
    if (this.currentMediaIndex === 0 || this.currentMediaIndex >= this.mediaList.length - 1) {
        console.log('üéØ Aplicando imediatamente (√≠ndice favor√°vel)...');
        setTimeout(() => {
            if (this.pendingPlaylistUpdate && !this.pendingPlaylistUpdate.applied) {
                this.applyPendingPlaylistUpdate();
            }
        }, 1000);
    }
}

// NOVO: Tratar atualiza√ß√µes de configura√ß√£o - CORRIGIDO
handleDeviceConfigUpdate(config) {
    console.log('‚öôÔ∏è Configura√ß√£o do dispositivo atualizada:', config);
    
    let configChanged = false;
    
    if (config.audioEnabled !== undefined && config.audioEnabled !== this.audioEnabled) {
        this.audioEnabled = config.audioEnabled;
        console.log(`üîä Configura√ß√£o de √°udio atualizada: ${this.audioEnabled ? 'habilitado' : 'desabilitado'}`);
        configChanged = true;
        
        // Aplicar configura√ß√£o de √°udio imediatamente em todos os elementos de v√≠deo
        if (this.videoDisplay) {
            this.videoDisplay.muted = !this.audioEnabled;
            console.log(`üé¨ √Åudio do v√≠deo ${this.audioEnabled ? 'habilitado' : 'mutado'}`);
        }
    }
    
    if (config.rotation && config.rotation !== this.rotation) {
        this.rotation = config.rotation;
        console.log(`üîÑ Configura√ß√£o de rota√ß√£o atualizada: ${this.rotation}`);
        configChanged = true;
        
        // Aplicar rota√ß√£o imediatamente
        this.applyRotation();
    }
        if (config.developer !== undefined && config.developer !== this.developerMode) {
        this.developerMode = config.developer;
        console.log(`üõ†Ô∏è Developer mode: ${this.developerMode}`);
        configChanged = true;

        this.toggleDeveloperElements();
    }
    if (configChanged) {
        // Salvar configura√ß√µes atualizadas
        const savedAuth = localStorage.getItem('deviceAuth');
        if (savedAuth) {
            const authData = JSON.parse(savedAuth);
            authData.audioEnabled = this.audioEnabled;
            authData.rotation = this.rotation;
            authData.developer = this.developerMode || false;
            localStorage.setItem('deviceAuth', JSON.stringify(authData));
            console.log('üíæ Configura√ß√µes salvas no localStorage');
        }
        
        // Mostrar notifica√ß√£o visual
        this.showConfigNotification();
    }
}
// NOVO: Mostrar notifica√ß√£o de configura√ß√£o aplicada
showConfigNotification() {
    if (this.developerMode) {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #27ae60;
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        z-index: 9999;
        font-weight: 600;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `;
    notification.textContent = '‚öôÔ∏è Configura√ß√µes aplicadas com sucesso!';
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        if (notification.parentElement) {
            notification.remove();
        }
    }, 3000);
    }
}
        // CORRIGIDA: Sincroniza√ß√£o que respeita o estado da playlist
        handleSyncCommand(data) {
            console.log('üîÑ Processando sincroniza√ß√£o da playlist:', data);
            
            this.clearTimers();
            this.stopAllMedia();
            
            // ARMAZENAR informa√ß√µes de sincroniza√ß√£o
            this.playlistSyncInfo = {
                currentMediaIndex: data.currentMediaIndex || 0,
                mediaStartTime: new Date(data.mediaStartTime),
                elapsedTime: data.elapsedTime || 0,
                remainingTime: data.remainingTime || 0,
                mediaDuration: data.mediaDuration || 0
            };
            
            console.log('üìä Estado da playlist recebido:', {
                mediaIndex: this.playlistSyncInfo.currentMediaIndex,
                elapsedTime: Math.round(this.playlistSyncInfo.elapsedTime / 1000) + 's',
                remainingTime: Math.round(this.playlistSyncInfo.remainingTime / 1000) + 's',
                mediaDuration: Math.round(this.playlistSyncInfo.mediaDuration / 1000) + 's'
            });
            
            // VERIFICAR se temos m√≠dias carregadas
            if (this.mediaList.length > 0) {
                this.applyPlaylistSync();
            } else {
                console.log('‚è≥ Aguardando carregamento das m√≠dias para aplicar sincroniza√ß√£o...');
            }
            
            this.showSyncNotification();
        }
// NOVA: Verificar se a sincroniza√ß√£o ainda √© v√°lida ap√≥s atualiza√ß√£o
isSyncStillValid(syncInfo) {
    if (!syncInfo || !this.mediaList.length) {
        return false;
    }
    
    // Verificar se o √≠ndice da sincroniza√ß√£o ainda existe na playlist
    if (syncInfo.currentMediaIndex >= this.mediaList.length) {
        console.log('‚ùå √çndice de sincroniza√ß√£o inv√°lido na nova playlist');
        return false;
    }
    
    // Verificar se a m√≠dia na posi√ß√£o sincronizada ainda √© a mesma (opcional)
    // Isso pode ser expandido para verificar por ID se necess√°rio
    
    return true;
}
// CORRE√á√ÉO: Aplicar sincroniza√ß√£o da playlist
applyPlaylistSync() {
    if (!this.playlistSyncInfo || this.mediaList.length === 0) {
        console.log('‚ùå Informa√ß√µes de sincroniza√ß√£o incompletas, usando reprodu√ß√£o normal');
        this.currentMediaIndex = 0;
        this.playNextMedia();
        return;
    }
    
    const syncInfo = this.playlistSyncInfo;
    const targetMediaIndex = syncInfo.currentMediaIndex;
    
    console.log(`üéØ Tentando sincronizar para √≠ndice: ${targetMediaIndex}`);
    console.log(`üìä Playlist tem ${this.mediaList.length} m√≠dias`);
    
    // VALIDAR √≠ndice da m√≠dia
    if (targetMediaIndex >= this.mediaList.length) {
        console.log(`‚ùå √çndice de m√≠dia inv√°lido (${targetMediaIndex}), usando √≠ndice 0`);
        this.currentMediaIndex = 0;
        this.playNextMedia();
        return;
    }
    
    const targetMedia = this.mediaList[targetMediaIndex];
    
    console.log(`üéØ Sincronizando para m√≠dia: ${targetMedia.originalName} (√≠ndice: ${targetMediaIndex})`);
    console.log(`‚è±Ô∏è ${Math.round(syncInfo.elapsedTime/1000)}s decorridos, ${Math.round(syncInfo.remainingTime/1000)}s restantes de ${Math.round(syncInfo.mediaDuration/1000)}s totais`);
    
    // CORRE√á√ÉO: Reproduzir m√≠dia espec√≠fica com sincroniza√ß√£o
    this.playMediaWithSync(targetMediaIndex, syncInfo.elapsedTime, syncInfo.remainingTime, syncInfo.mediaDuration);
}

        // CORRIGIDA: Atualizar timing da m√≠dia atual
        updateCurrentMediaTiming(elapsedTime, remainingTime, mediaDuration) {
            console.log(`‚è∞ Atualizando timing: ${Math.round(elapsedTime/1000)}s decorridos, ${Math.round(remainingTime/1000)}s restantes de ${Math.round(mediaDuration/1000)}s totais`);
            
            this.clearTimers();
            
            const remainingSeconds = Math.round(remainingTime / 1000);
            const totalSeconds = Math.round(mediaDuration / 1000);
            
            this.mediaTimeElement.textContent = `${remainingSeconds}s/${totalSeconds}s`;
            this.startCountdown(remainingTime);
            
            // CONFIGURAR timeout para pr√≥xima m√≠dia
            this.currentTimeout = setTimeout(() => {
                console.log('‚è∞ Timer da m√≠dia atual finalizado, indo para pr√≥xima...');
                this.playNextMedia();
            }, remainingTime);
            
            // APLICAR seek em v√≠deos se necess√°rio
            if (this.currentMedia && this.currentMedia.type === 'video' && !this.currentMedia.isExternal) {
                this.applyVideoSeek(elapsedTime);
            }
            
            this.sendCurrentMedia();
        }

        // CORRE√á√ÉO: Reproduzir m√≠dia espec√≠fica com sincroniza√ß√£o
        playMediaWithSync(mediaIndex, elapsedTime, remainingTime, mediaDuration) {
            if (mediaIndex >= this.mediaList.length) {
                console.log('‚ùå √çndice de m√≠dia inv√°lido, usando √≠ndice 0');
                mediaIndex = 0;
            }
            
            // CORRE√á√ÉO: Atualizar o √≠ndice atual para a m√≠dia sincronizada
            this.currentMediaIndex = mediaIndex;
            const media = this.mediaList[mediaIndex];
            
            console.log(`üé¨ Reproduzindo m√≠dia sincronizada: ${media.originalName} (√≠ndice: ${mediaIndex})`);
            console.log(`‚è±Ô∏è ${Math.round(elapsedTime/1000)}s decorridos, ${Math.round(remainingTime/1000)}s restantes de ${Math.round(mediaDuration/1000)}s totais`);
            
            this.currentMedia = media;
            this.stopAllMedia();
            
            const remainingSeconds = Math.round(remainingTime / 1000);
            const totalSeconds = Math.round(mediaDuration / 1000);
            
            this.currentMediaElement.textContent = media.originalName;
            this.mediaTimeElement.textContent = `${remainingSeconds}s/${totalSeconds}s`;
            this.debugInfo.textContent = `Sincronizado: ${media.originalName} (${remainingSeconds}s)`;
            
            // CONFIGURAR timeout para pr√≥xima m√≠dia
            this.clearTimers();
            this.currentTimeout = setTimeout(() => {
                console.log('‚è∞ Timer da m√≠dia sincronizada finalizado, indo para pr√≥xima...');
                
                // CORRE√á√ÉO: Calcular pr√≥ximo √≠ndice corretamente
                const nextIndex = (this.currentMediaIndex + 1) % this.mediaList.length;
                console.log(`üìä Pr√≥ximo √≠ndice ap√≥s sincroniza√ß√£o: ${nextIndex}`);
                this.currentMediaIndex = nextIndex;
                this.playNextMedia();
            }, remainingTime);
            
            this.startCountdown(remainingTime);
            this.sendCurrentMedia();
            
            // REPRODUZIR m√≠dia com seek
            this.playMediaByType(media, elapsedTime);
            
            // DEBUG: Log do estado ap√≥s sincroniza√ß√£o
            console.log(`üîç DEBUG SYNCMEDIA: √çndice definido: ${this.currentMediaIndex}, Pr√≥xima m√≠dia ser√°: ${(this.currentMediaIndex + 1) % this.mediaList.length}`);
        }


        // NOVO: M√©todo para debug - verificar estado da sincroniza√ß√£o
        debugSyncState() {
            console.log('üêõ DEBUG - Estado da Sincroniza√ß√£o:');
            console.log('üìä Playlist Sync Info:', this.playlistSyncInfo);
            console.log('üé¨ M√≠dia Atual:', this.currentMedia?.originalName);
            console.log('üìà √çndice Atual:', this.currentMediaIndex);
            console.log('üìã Total de M√≠dias:', this.mediaList.length);
            console.log('‚è∞ Timeout Ativo:', !!this.currentTimeout);
            console.log('üîí Playback Lock:', this.playbackLock);
        }

        // CORRIGIDA: Reproduzir m√≠dia considerando tempo decorrido
        playMediaByType(media, elapsedTime = 0) {
            const totalDuration = (media.displayTime || 10) * 1000;
            const seekTime = elapsedTime > 0 ? elapsedTime : 0;
            
            console.log(`üé¨ Reproduzindo: ${media.originalName}, seek: ${Math.round(seekTime/1000)}s`);
            
            switch(media.mediaType) {
                case 'upload':
                    if (media.type === 'image') {
                        this.playUploadedImage(media);
                    } else {
                        this.playUploadedVideo(media, seekTime);
                    }
                    break;
                case 'youtube':
                    this.playYouTube(media, seekTime);
                    break;
                case 'website':
                    this.playWebsite(media);
                    break;
                default:
                    console.warn('Tipo de m√≠dia n√£o suportado:', media.mediaType);
                    setTimeout(() => this.playNextMedia(), 2000);
            }
        }

        applyVideoSeek(elapsedTime) {
            if (this.videoDisplay && this.videoDisplay.readyState >= 2) {
                const seekSeconds = elapsedTime / 1000;
                if (seekSeconds < this.videoDisplay.duration) {
                    this.videoDisplay.currentTime = seekSeconds;
                    console.log(`‚è© Video seek aplicado: ${seekSeconds}s`);
                }
            }
        }

        // CORRE√á√ÉO: Buscar informa√ß√µes de sincroniza√ß√£o da playlist ao conectar
        async fetchPlaylistSyncInfo() {
            if (!this.deviceInfo || !this.deviceInfo.playlistId) {
                console.log('‚ÑπÔ∏è Dispositivo n√£o tem playlist espec√≠fica');
                return null;
            }
            
            try {
                console.log(`üîç Buscando informa√ß√µes de sincroniza√ß√£o para playlist: ${this.deviceInfo.playlistId}`);
                
                // CORRE√á√ÉO: N√£o enviar headers de autentica√ß√£o para esta rota
                const response = await fetch(`${this.serverUrl}/api/playlists/${this.deviceInfo.playlistId}/sync-info`);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('üìä Informa√ß√µes de sincroniza√ß√£o da playlist:', data.currentState);
                    return data.currentState;
                } else {
                    console.log('‚ùå N√£o foi poss√≠vel obter informa√ß√µes de sincroniza√ß√£o');
                    return null;
                }
            } catch (error) {
                console.error('‚ùå Erro ao buscar informa√ß√µes de sincroniza√ß√£o:', error);
                return null;
            }
        }

        showAuthScreen() {
            console.log('üéØ Mostrando tela de autentica√ß√£o...');
            this.authScreen.classList.remove('hidden');
            this.connectionError.classList.add('hidden');
            this.statusOverlay.classList.add('hidden');
            this.deviceStatusElement.textContent = 'Aguardando autentica√ß√£o';
            this.hideLoading();
        }

        hideAuthScreen() {
            console.log('üéØ Ocultando tela de autentica√ß√£o...');
            this.authScreen.classList.add('hidden');
            this.authError.style.display = 'none';
            this.hideLoading();
            
            if (this.codeGenerationInterval) {
                clearInterval(this.codeGenerationInterval);
                this.codeGenerationInterval = null;
            }
        }

// ATUALIZAR: Iniciar playback aplicando sincroniza√ß√£o corretamente
async startPlayback() {
    console.log('üöÄ Iniciando playback para dispositivo:', this.deviceInfo);
    
    this.hideAuthScreen();
    this.connectionError.classList.add('hidden');
    this.statusOverlay.classList.remove('hidden');
    this.debugPanel.classList.remove('hidden');
    
    this.deviceNameElement.textContent = this.deviceInfo.name;
    this.debugInfo.textContent = `Conectado: ${this.deviceInfo.name}`;
    this.deviceStatusElement.textContent = 'Autenticado';
    
    // NOVO: Aplicar configura√ß√µes do dispositivo
    this.applyDeviceConfig();
    this.toggleDeveloperElements();
    if (this.activationInterval) {
        clearInterval(this.activationInterval);
        this.activationInterval = null;
    }
    
    if (this.codeGenerationInterval) {
        clearInterval(this.codeGenerationInterval);
        this.codeGenerationInterval = null;
    }
    
    // PRIMEIRO: Buscar informa√ß√µes de sincroniza√ß√£o da playlist (se tiver playlist)
    if (this.deviceInfo.playlistId) {
        console.log('üéØ Dispositivo tem playlist espec√≠fica, buscando sincroniza√ß√£o...');
        const playlistSyncInfo = await this.fetchPlaylistSyncInfo();
        
        if (playlistSyncInfo) {
            console.log('üéØ Sincroniza√ß√£o da playlist encontrada:', playlistSyncInfo);
            this.playlistSyncInfo = playlistSyncInfo;
        } else {
            console.log('‚ÑπÔ∏è Nenhuma sincroniza√ß√£o dispon√≠vel para a playlist');
        }
    } else {
        console.log('üéØ Dispositivo sem playlist espec√≠fica');
    }
    
    // DEPOIS: Carregar m√≠dias
    await this.loadMediaList();
    
    this.connectWebSocket();
}

        showErrorScreen(message) {
            console.log('‚ùå Mostrando tela de erro:', message);
            this.errorMessage.textContent = message;
            this.connectionError.classList.remove('hidden');
            this.statusOverlay.classList.add('hidden');
            this.authScreen.classList.add('hidden');
            this.hideLoading();
            this.clearTimers();
            this.stopAllMedia();
        }

        playUploadedImage(media) {
            this.showLoading(`Carregando imagem: ${media.originalName}`);
            
            this.mediaDisplay.onload = () => {
                console.log('‚úÖ Imagem carregada');
                this.hideLoading();
                this.mediaDisplay.classList.remove('hidden');
                // NOVO: Aplicar rota√ß√£o
                this.mediaDisplay.classList.add(this.rotation);
            };
            
            this.mediaDisplay.onerror = () => {
                console.error('‚ùå Erro ao carregar imagem');
                this.hideLoading();
                setTimeout(() => this.playNextMedia(), 2000);
            };
            
            this.mediaDisplay.src = `${this.serverUrl}${media.path}?t=${Date.now()}`;
        }

        playUploadedVideo(media, seekTime = 0) {
            this.showLoading(`Carregando v√≠deo: ${media.originalName}`);
            
            // CORRE√á√ÉO: Lidar com autoplay bloqueado
            const handlePlay = () => {
                console.log('‚úÖ V√≠deo carregado e pronto para reprodu√ß√£o');
                this.hideLoading();
                this.videoDisplay.classList.remove('hidden');
                // NOVO: Aplicar rota√ß√£o
                this.videoDisplay.classList.add(this.rotation);
                
                // NOVO: Aplicar configura√ß√£o de √°udio
                this.videoDisplay.muted = !this.audioEnabled;
                
                if (seekTime > 0) {
                    const seekSeconds = seekTime / 1000;
                    this.videoDisplay.currentTime = Math.min(seekSeconds, this.videoDisplay.duration - 1);
                    console.log(`‚è© Video seek para: ${seekSeconds}s`);
                }
                
                // TENTAR reproduzir, mas n√£o falhar se bloqueado
                this.videoDisplay.play().catch(e => {
                    console.log('‚ö†Ô∏è Autoplay bloqueado, aguardando intera√ß√£o ou reproduzindo sem √°udio');
                    // N√£o fazer nada - o v√≠deo pode ser reproduzido sem √°udio
                });
            };
            
            this.videoDisplay.onloadeddata = handlePlay;
            this.videoDisplay.onerror = () => {
                console.error('‚ùå Erro ao carregar v√≠deo');
                this.hideLoading();
                setTimeout(() => this.playNextMedia(), 2000);
            };
            
            this.videoDisplay.onended = () => {
                console.log('‚è≠Ô∏è V√≠deo finalizado');
                this.playNextMedia();
            };
            
            this.videoDisplay.src = `${this.serverUrl}${media.path}?t=${Date.now()}`;
            this.videoDisplay.playsInline = true; // Importante para iOS
        }

        playYouTube(media, seekTime = 0) {
            this.showLoading(`Carregando YouTube: ${media.originalName}`);
            
            const videoId = this.extractYouTubeId(media.path);
            if (!videoId) {
                console.error('‚ùå URL do YouTube inv√°lida');
                this.hideLoading();
                setTimeout(() => this.playNextMedia(), 2000);
                return;
            }
            
            let startParam = '';
            if (seekTime > 0) {
                const startSeconds = Math.floor(seekTime / 1000);
                startParam = `&start=${startSeconds}`;
                console.log(`‚è© YouTube start em: ${startSeconds}s`);
            }
            
            const embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1&controls=0&modestbranding=1&rel=0&enablejsapi=1${startParam}`;
            
            this.youtubeDisplay.onload = () => {
                console.log('‚úÖ YouTube carregado');
                this.hideLoading();
                this.youtubeDisplay.classList.remove('hidden');
                // NOVO: Aplicar rota√ß√£o
                this.youtubeDisplay.classList.add(this.rotation);
            };
            
            this.youtubeDisplay.onerror = () => {
                console.error('‚ùå Erro ao carregar YouTube');
                this.hideLoading();
                setTimeout(() => this.playNextMedia(), 2000);
            };
            
            this.youtubeDisplay.src = embedUrl;
        }

        playWebsite(media) {
            this.showLoading(`Carregando site: ${media.originalName}`);
            
            this.webDisplay.onload = () => {
                console.log('‚úÖ Site carregado');
                this.hideLoading();
                this.webDisplay.classList.remove('hidden');
                // NOVO: Aplicar rota√ß√£o
                this.webDisplay.classList.add(this.rotation);
            };
            
            this.webDisplay.onerror = () => {
                console.error('‚ùå Erro ao carregar site');
                this.hideLoading();
                setTimeout(() => this.playNextMedia(), 2000);
            };
            
            this.webDisplay.src = media.path;
        }

        stopAllMedia() {
            this.mediaDisplay.classList.add('hidden');
            this.videoDisplay.classList.add('hidden');
            this.youtubeDisplay.classList.add('hidden');
            this.webDisplay.classList.add('hidden');
            
            if (this.videoDisplay) {
                this.videoDisplay.pause();
                this.videoDisplay.currentTime = 0;
            }
        }

        clearTimers() {
            if (this.currentTimeout) {
                clearTimeout(this.currentTimeout);
                this.currentTimeout = null;
            }
            
            if (this.currentCountdown) {
                clearInterval(this.currentCountdown);
                this.currentCountdown = null;
            }
            
            // this.countdownElement.classList.add('hidden');
        }

        extractYouTubeId(url) {
            const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
            const match = url.match(regex);
            return match ? match[1] : null;
        }

        startCountdown(duration) {
            // this.countdownElement.classList.remove('hidden');
            let timeLeft = duration / 1000;
            this.countdownTimer.textContent = Math.round(timeLeft);
            
            if (this.currentCountdown) {
                clearInterval(this.currentCountdown);
            }
            
            this.currentCountdown = setInterval(() => {
                timeLeft--;
                this.countdownTimer.textContent = Math.round(timeLeft);
                
                if (timeLeft <= 0) {
                    clearInterval(this.currentCountdown);
                    // this.countdownElement.classList.add('hidden');
                }
            }, 1000);
        }

        showLoading(message) {
            this.loadingElement.textContent = message;
            this.loadingElement.classList.remove('hidden');
        }
        
        hideLoading() {
            this.loadingElement.classList.add('hidden');
        }

        sendCurrentMedia() {
            const now = Date.now();
            if (now - this.lastMediaUpdate < 10000) {
                return;
            }
            
            if (this.ws && this.ws.readyState === WebSocket.OPEN && this.currentMedia) {
                const mediaInfo = {
                    type: 'current_media',
                    deviceId: this.deviceId,
                    media: this.currentMedia,
                    currentMediaIndex: this.currentMediaIndex,
                    timestamp: new Date()
                };
                
                this.ws.send(JSON.stringify(mediaInfo));
                this.lastMediaUpdate = now;
            }
        }

 // NOVO: M√©todo para verificar e corrigir estado do √≠ndice
        validateMediaIndex() {
            if (this.currentMediaIndex >= this.mediaList.length) {
                console.warn('‚ö†Ô∏è √çndice de m√≠dia inv√°lido, corrigindo para 0');
                this.currentMediaIndex = 0;
            }
            
            console.log(`üîç VALIDA√á√ÉO: √çndice atual: ${this.currentMediaIndex}, Total de m√≠dias: ${this.mediaList.length}`);
            return this.currentMediaIndex;
        }

// ATUALIZAR: Carregar m√≠dias sem reiniciar automaticamente se h√° atualiza√ß√£o pendente
async loadMediaList() {
    if (this.isLoadingMedia) {
        console.log('‚è≥ J√° est√° carregando m√≠dias, aguardando...');
        return;
    }
    
    this.isLoadingMedia = true;
    
    try {
        this.showLoading('Carregando conte√∫do...');
        
        const response = await fetch(`${this.serverUrl}/api/player/media`, {
            headers: {
                'x-device-mac': this.deviceMac
            }
        });
        
        if (response.ok) {
            const newMediaList = await response.json();
            console.log(`üìã ${newMediaList.length} m√≠dia(s) carregada(s)`);
            
            // SALVAR a lista antiga para compara√ß√£o
            const oldMediaList = this.mediaList;
            this.mediaList = newMediaList;
            
            if (this.mediaList.length > 0) {
                this.hideLoading();
                
                // CORRE√á√ÉO: Validar √≠ndice antes de usar
                this.validateMediaIndex();
                
                // SE temos sincroniza√ß√£o da playlist, aplicar
                if (this.playlistSyncInfo) {
                    console.log('üéØ Aplicando sincroniza√ß√£o da playlist ap√≥s carregamento');
                    this.applyPlaylistSync();
                } else if (!this.pendingPlaylistUpdate) {
                    // CORRE√á√ÉO: S√≥ iniciar automaticamente se N√ÉO h√° atualiza√ß√£o pendente
                    console.log(`üé¨ Iniciando reprodu√ß√£o normal do √≠ndice: ${this.currentMediaIndex}`);
                    this.playNextMedia();
                } else {
                    console.log('‚è≥ Atualiza√ß√£o pendente, aguardando ciclo completo para aplicar');
                }
            } else {
                this.showLoading('‚ö†Ô∏è Nenhum conte√∫do dispon√≠vel');
            }
        } else {
            throw new Error('Erro ao carregar conte√∫do');
        }
    } catch (error) {
        console.error('‚ùå Erro ao carregar m√≠dias:', error);
        this.showErrorScreen('Erro ao carregar conte√∫do');
    } finally {
        this.isLoadingMedia = false;
    }
}
        //  Verificar se a lista de m√≠dias mudou significativamente
        hasMediaListChanged(oldList, newList) {
            if (oldList.length !== newList.length) {
                return true;
            }
            
            // Verificar se os IDs s√£o os mesmos
            const oldIds = oldList.map(m => m.id).sort();
            const newIds = newList.map(m => m.id).sort();
            
            return !oldIds.every((id, index) => id === newIds[index]);
        }


//
        // NOVA: Mostrar notifica√ß√£o de atualiza√ß√£o pendente
        showUpdateNotification() {
                if (this.developerMode) {   
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #ffa500;
                color: white;
                padding: 10px 20px;
                border-radius: 8px;
                z-index: 9999;
                font-weight: 600;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                text-align: center;
            `;
            notification.innerHTML = 'üîÑ Playlist atualizada - Ser√° aplicada no pr√≥ximo ciclo';
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 5000);
        }
        }
// CORRE√á√ÉO DEFINITIVA: Reproduzir pr√≥xima m√≠dia com verifica√ß√£o robusta de atualiza√ß√£o
playNextMedia() {
    if (this.playbackLock) {
        console.log('‚è∏Ô∏è  Playback bloqueado, aguardando...');
        return;
    }
    
    if (this.mediaList.length === 0) {
        console.log('‚ùå Nenhuma m√≠dia para reproduzir');
        return;
    }
    
    this.clearTimers();
    
    console.log(`üîç VERIFICA√á√ÉO: √çndice atual: ${this.currentMediaIndex}, Total: ${this.mediaList.length}, Pendente: ${this.pendingPlaylistUpdate ? 'SIM' : 'N√ÉO'}`);
    
    // VERIFICA√á√ÉO ROBUSTA: Se temos atualiza√ß√£o pendente E estamos no ciclo completo
    if (this.pendingPlaylistUpdate && !this.pendingPlaylistUpdate.applied) {
        const isAtStart = this.currentMediaIndex === 0;
        const isAtEnd = this.currentMediaIndex >= this.mediaList.length - 1;
        const willRestart = this.currentMediaIndex >= this.mediaList.length;
        
        console.log(`üîÑ Status: In√≠cio=${isAtStart}, Fim=${isAtEnd}, Reiniciar√°=${willRestart}`);
        
        // APLICAR atualiza√ß√£o se estamos no final OU prestes a reiniciar
        if (willRestart || isAtEnd) {
            console.log('üîÑ Condi√ß√£o de atualiza√ß√£o atendida - Aplicando nova playlist...');
            this.applyPendingPlaylistUpdate();
            return;
        }
    }
    
    // CORRE√á√ÉO: Verificar se chegou ao final da playlist
    if (this.currentMediaIndex >= this.mediaList.length) {
        this.currentMediaIndex = 0;
        console.log('üîÑ Fim da playlist, reiniciando do √≠ndice 0...');
        
        // VERIFICAR NOVAMENTE ap√≥s reset para 0
        if (this.pendingPlaylistUpdate && !this.pendingPlaylistUpdate.applied) {
            console.log('üîÑ √çndice resetado para 0 - Aplicando atualiza√ß√£o da playlist...');
            this.applyPendingPlaylistUpdate();
            return;
        }
    }
    
    const media = this.mediaList[this.currentMediaIndex];
    console.log(`üé¨ Reproduzindo m√≠dia ${this.currentMediaIndex + 1}/${this.mediaList.length}: ${media.originalName}`);
    
    // CORRE√á√ÉO: Reproduzir a m√≠dia atual ANTES de incrementar o √≠ndice
    this.playMedia(media);
    
    // CORRE√á√ÉO: Incrementar √≠ndice AP√ìS reproduzir a m√≠dia atual
    this.currentMediaIndex = (this.currentMediaIndex + 1) % this.mediaList.length;
    console.log(`üìä Pr√≥ximo √≠ndice ser√°: ${this.currentMediaIndex}`);
}


// ADICIONAR: Verifica√ß√£o no playMedia para detectar ciclo completo
playMedia(media, isAnnouncement = false) {
    if (this.playbackLock && this.currentMedia && this.currentMedia.id === media.id) {
        console.log('‚è∏Ô∏è  M√≠dia j√° est√° sendo reproduzida, ignorando...');
        return;
    }
    
    // VERIFICAR se temos atualiza√ß√£o pendente ao iniciar nova m√≠dia
    if (this.pendingPlaylistUpdate && !this.pendingPlaylistUpdate.applied && this.currentMediaIndex === 0) {
        console.log('üîÑ Iniciando m√≠dia no √≠ndice 0 com atualiza√ß√£o pendente - Aplicando...');
        this.applyPendingPlaylistUpdate();
        return;
    }
    
    this.currentMedia = media;
    this.stopAllMedia();
    this.playbackLock = true;
    
    this.currentMediaElement.textContent = media.originalName;
    
    const displayTime = (media.displayTime || 10) * 1000;
    const displaySeconds = Math.round(displayTime / 1000);
    
    this.mediaTimeElement.textContent = `${displaySeconds}s/${displaySeconds}s`;
    this.debugInfo.textContent = `Reproduzindo: ${media.originalName} ${isAnnouncement ? '(Anunciamento)' : ''}`;
    
    this.mediaStartTime = new Date();
    
    this.startCountdown(displayTime);
    
    if (this.currentTimeout) {
        clearTimeout(this.currentTimeout);
    }
    
    this.currentTimeout = setTimeout(() => {
        console.log('‚è∞ Timer da m√≠dia finalizado, indo para pr√≥xima...');
        this.playbackLock = false;
        if (!isAnnouncement) {
            this.playNextMedia();
        }
    }, displayTime);
    
    this.sendCurrentMedia();
    this.playMediaByType(media, 0);
    
    // DEBUG: Log do estado atual
    console.log(`üîç DEBUG PLAYMEDIA: √çndice atual: ${this.currentMediaIndex}, M√≠dia: ${media.originalName}`);
}
// CORRE√á√ÉO: Aplicar atualiza√ß√£o pendente da playlist com reset correto
async applyPendingPlaylistUpdate() {
    if (!this.pendingPlaylistUpdate || this.pendingPlaylistUpdate.applied) {
        console.log('‚ÑπÔ∏è Nenhuma atualiza√ß√£o pendente para aplicar');
        return;
    }
    
    console.log('üîÑ APLICANDO ATUALIZA√á√ÉO DA PLAYLIST...');
    
    this.showLoading('Atualizando playlist...');
    this.clearTimers();
    this.stopAllMedia();
    
    // CORRE√á√ÉO IMPORTANTE: Resetar o playbackLock ANTES de recarregar
    this.playbackLock = false;
    
    try {
        console.log('üì• Recarregando lista de m√≠dias...');
        
        // Recarregar a lista de m√≠dias
        const response = await fetch(`${this.serverUrl}/api/player/media`, {
            headers: {
                'x-device-mac': this.deviceMac
            }
        });
        
        if (!response.ok) {
            throw new Error('Erro ao carregar conte√∫do');
        }
        
        const newMediaList = await response.json();
        console.log(`üìã ${newMediaList.length} nova(s) m√≠dia(s) carregada(s)`);
        
        // ATUALIZAR lista de m√≠dias
        this.mediaList = newMediaList;
        
        if (this.mediaList.length === 0) {
            throw new Error('Nenhuma m√≠dia dispon√≠vel na nova playlist');
        }
        
        // SEMPRE reiniciar do √≠ndice 0 para nova playlist
        this.currentMediaIndex = 0;
        console.log('üîÑ Reiniciando reprodu√ß√£o do √≠ndice 0 com nova playlist');
        
        // Marcar como aplicada e LIMPAR
        this.pendingPlaylistUpdate.applied = true;
        this.pendingPlaylistUpdate.appliedAt = new Date();
        this.pendingPlaylistUpdate = null;
        
        console.log('‚úÖ Atualiza√ß√£o da playlist aplicada com sucesso!');
        
        // Mostrar notifica√ß√£o de sucesso
        this.showUpdateAppliedNotification();
        
        // CORRE√á√ÉO: Garantir que o playbackLock est√° desbloqueado
        this.playbackLock = false;
        
        // Reiniciar reprodu√ß√£o do √≠ndice 0
        this.hideLoading();
        this.playNextMedia();
        
    } catch (error) {
        console.error('‚ùå Erro ao aplicar atualiza√ß√£o da playlist:', error);
        
        // CORRE√á√ÉO: Resetar estado mesmo em caso de erro
        this.pendingPlaylistUpdate = null;
        this.playbackLock = false;
        
        // Tentar continuar com a playlist atual
        this.currentMediaIndex = 0;
        this.hideLoading();
        this.playNextMedia();
    }
}
// NOVA: Mostrar notifica√ß√£o de atualiza√ß√£o aplicada
showUpdateAppliedNotification() {
    if (this.developerMode) {    
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #27ae60;
        color: white;
        padding: 10px 20px;
        border-radius: 8px;
        z-index: 9999;
        font-weight: 600;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        text-align: center;
    `;
    notification.innerHTML = '‚úÖ Playlist atualizada - Nova programa√ß√£o em execu√ß√£o';
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        if (notification.parentElement) {
            notification.remove();
        }
    }, 5000);
}
}
        handleAnnouncement(data) {
            console.log('üì¢ Anunciamento recebido:', data.announcement.name);
            
            this.clearTimers();
            this.stopAllMedia();
            
            this.playMedia(data.media, true);
            
            setTimeout(() => {
                if (this.playlistSyncInfo) {
                    this.applyPlaylistSync();
                } else {
                    this.loadMediaList();
                }
            }, data.announcement.displayTime * 1000);
        }
        
        handleAnnouncementCancelled(data) {
            console.log('üõë Anunciamento cancelado');
            if (this.playlistSyncInfo) {
                this.applyPlaylistSync();
            } else {
                this.loadMediaList();
            }
        }
        
        handleDeviceDisconnected(data) {
            console.log('üîå Dispositivo desconectado pelo administrador');
            
            localStorage.removeItem('deviceAuth');
            this.deviceId = null;
            this.deviceInfo = null;
            this.playlistSyncInfo = null;
            
            this.clearTimers();
            this.stopAllMedia();
            
            this.startCodeGeneration();
            this.startActivationPolling();
            this.showAuthScreen();
            
            if (this.ws) {
                this.ws.close();
            }
        }
        
        showSyncNotification() {
        if (this.developerMode) {    
            this.syncNotification.classList.remove('hidden');
            setTimeout(() => {
                this.syncNotification.classList.add('hidden');
            }, 3000);
        }
        }
    }
    
    let mediaPlayer;
    
    document.addEventListener('DOMContentLoaded', () => {
        mediaPlayer = new MediaPlayer();
    });

    document.addEventListener('dragstart', (e) => e.preventDefault());
    
    window.addEventListener('error', (e) => {
        console.error('üö® Erro global:', e.error);
    });
</script>
</body>
</html>