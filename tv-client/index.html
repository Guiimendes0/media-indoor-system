<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Media Indoor Player</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        #player-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #media-display, #video-display, #web-display {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border: none;
        }
        
        #youtube-display {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Tela de Autentica√ß√£o Atualizada */
        #auth-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            flex-direction: column;
            text-align: center;
            padding: 20px;
        }

        .auth-container {
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            width: 90%;
            max-width: 500px;
            color: #333;
        }

        .logo-container {
            margin-bottom: 20px;
        }

        .logo-image {
            max-width: 200px;
            max-height: 100px;
            margin-bottom: 15px;
        }

        .auth-container h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1.8rem;
        }

        .auth-container p {
            color: #666;
            margin-bottom: 20px;
        }

        .auth-code-display {
            background: #f8f9fa;
            border: 2px dashed #3498db;
            border-radius: 10px;
            padding: 25px;
            margin: 20px 0;
            text-align: center;
        }

        .auth-code {
            font-family: 'Courier New', monospace;
            font-size: 2.5rem;
            font-weight: bold;
            color: #2c3e50;
            letter-spacing: 8px;
            margin: 10px 0;
        }

        .code-expiry {
            color: #e74c3c;
            font-size: 0.9rem;
            margin-top: 10px;
            font-weight: bold;
        }

        .device-info {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 14px;
            text-align: left;
        }

        .device-info strong {
            color: #2c3e50;
        }

        /* Status e controles */
        #status-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
            border: 1px solid #333;
        }
        
        #connection-error {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 100;
            padding: 20px;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 8px;
            z-index: 50;
        }
        
        .countdown {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }

        .debug-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #ccc;
            z-index: 100;
        }

        .sync-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(52, 152, 219, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            z-index: 200;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="player-container">
        <!-- Tela de Autentica√ß√£o Atualizada -->
        <div id="auth-screen">
            <div class="auth-container">
                <div class="logo-container">
                    <!-- Espa√ßo para logo - substitua o src pela URL da sua logo -->
                    <img src="../tv-client/assets/Pantanera-logo.png" 
                         alt="Media Indoor Logo" class="logo-image">
                </div>
                
                <h1>Media Staff</h1>
                <p>Use o c√≥digo abaixo para cadastrar este dispositivo no painel administrativo</p>
                
                <div class="auth-code-display">
                    <div style="color: #666; margin-bottom: 10px;">C√≥digo de Ativa√ß√£o:</div>
                    <div class="auth-code" id="generatedAuthCode">------</div>
                    <div class="code-expiry" id="codeExpiry">Gerando novo c√≥digo...</div>
                </div>
                
                <div class="device-info">
                    <strong>Identificador do Dispositivo:</strong> <span id="device-mac">Carregando...</span><br>
                    <strong>Status:</strong> <span id="device-status">N√£o autenticado</span><br>
                    <small>Este c√≥digo √© v√°lido por 5 minutos. Ap√≥s esse per√≠odo, um novo c√≥digo ser√° gerado automaticamente.</small>
                </div>

                <div id="auth-error" style="color: #e74c3c; margin-top: 15px; display: none;"></div>
            </div>
        </div>
        
        <!-- Tela de Erro -->
        <div id="connection-error" class="hidden">
            <h1 style="color: #e74c3c; margin-bottom: 20px; font-size: 2rem;">‚ùå Erro de Conex√£o</h1>
            <p style="font-size: 1.2rem; margin-bottom: 10px;" id="error-message">Erro ao conectar com o servidor</p>
            <button onclick="location.reload()" style="padding: 10px 20px; margin-top: 20px; font-size: 16px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer;">
                üîÑ Tentar Novamente
            </button>
        </div>
        
        <!-- Loading -->
        <div class="loading hidden" id="loading">üîÑ Carregando...</div>

        <!-- Notifica√ß√£o de Sincroniza√ß√£o -->
        <div class="sync-notification hidden" id="syncNotification">
            üîÑ Sincronizando...
        </div>
        
        <!-- M√≠dias -->
        <img id="media-display" class="hidden" alt="M√≠dia">
        <video id="video-display" class="hidden" loop></video>
        <iframe id="youtube-display" class="hidden" allowfullscreen></iframe>
        <iframe id="web-display" class="hidden" allowfullscreen></iframe>
        
        <!-- Status -->
        <div id="status-overlay" class="hidden">
            <div style="margin-bottom: 5px;">‚úÖ <strong id="device-name">-</strong></div>
            <div style="margin-bottom: 5px;">üé¨ <span id="current-media">-</span></div>
            <div style="margin-bottom: 5px;">‚è±Ô∏è <span id="media-time">-</span></div>
            <div>üîó <span id="ws-status">Desconectado</span></div>
        </div>
        
        <!-- Countdown -->
        <div class="countdown hidden" id="countdown">
            Pr√≥xima m√≠dia em: <span id="countdown-timer">0</span>s
        </div>
        
        <!-- Debug -->
        <div class="debug-panel hidden" id="debug-panel">
            <div>Media Indoor Player</div>
            <div id="debug-info">Conectando...</div>
        </div>
    </div>

<script>
    class MediaPlayer {
        constructor() {
            this.serverUrl = window.location.origin;
            this.wsUrl = `ws://${window.location.host}`;
            this.currentMediaIndex = 0;
            this.mediaList = [];
            this.deviceInfo = null;
            this.currentTimeout = null;
            this.currentCountdown = null;
            this.deviceMac = null;
            this.currentMedia = null;
            this.ws = null;
            this.deviceId = null;
            this.playlistSyncInfo = null;
            
            // Elementos DOM
            this.authScreen = document.getElementById('auth-screen');
            this.connectionError = document.getElementById('connection-error');
            this.errorMessage = document.getElementById('error-message');
            this.loadingElement = document.getElementById('loading');
            this.statusOverlay = document.getElementById('status-overlay');
            this.deviceNameElement = document.getElementById('device-name');
            this.currentMediaElement = document.getElementById('current-media');
            this.mediaTimeElement = document.getElementById('media-time');
            this.wsStatusElement = document.getElementById('ws-status');
            this.debugInfo = document.getElementById('debug-info');
            this.debugPanel = document.getElementById('debug-panel');
            this.countdownElement = document.getElementById('countdown');
            this.countdownTimer = document.getElementById('countdown-timer');
            this.deviceMacElement = document.getElementById('device-mac');
            this.deviceStatusElement = document.getElementById('device-status');
            this.authError = document.getElementById('auth-error');
            this.syncNotification = document.getElementById('syncNotification');
            this.generatedAuthCode = document.getElementById('generatedAuthCode');
            this.codeExpiryElement = document.getElementById('codeExpiry');
            
            // Elementos de m√≠dia
            this.mediaDisplay = document.getElementById('media-display');
            this.videoDisplay = document.getElementById('video-display');
            this.youtubeDisplay = document.getElementById('youtube-display');
            this.webDisplay = document.getElementById('web-display');

            // Controles de estado
            this.isLoadingMedia = false;
            this.playbackLock = false;
            this.lastMediaUpdate = 0;
            this.autoPlayAttempted = false;
            
            this.init();
        }
        
        async init() {
            console.log('üé¨ Iniciando Media Indoor Player...');
            
            await this.generateDeviceMac();
            await this.checkAuthenticationStatus();
            this.startCodeGeneration();
            this.startActivationPolling();
        }

        startActivationPolling() {
            console.log('üîÑ Iniciando verifica√ß√£o peri√≥dica de ativa√ß√£o...');
            
            this.activationInterval = setInterval(async () => {
                if (this.deviceId) {
                    clearInterval(this.activationInterval);
                    return;
                }
                
                try {
                    const response = await fetch(`${this.serverUrl}/api/client/check-activation`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            mac: this.deviceMac
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        if (result.activated && result.device) {
                            console.log('üéâ Dispositivo foi ativado!', result.device);
                            this.deviceId = result.device.id;
                            this.deviceInfo = result.device;
                            
                            localStorage.setItem('deviceAuth', JSON.stringify({
                                deviceId: this.deviceId,
                                mac: this.deviceMac,
                                activatedAt: new Date()
                            }));
                            
                            if (this.codeGenerationInterval) {
                                clearInterval(this.codeGenerationInterval);
                                this.codeGenerationInterval = null;
                            }
                            
                            this.startPlayback();
                        }
                    }
                } catch (error) {
                    console.log('Verifica√ß√£o de ativa√ß√£o:', error.message);
                }
            }, 5000);
        }

        async generateDeviceMac() {
            let savedMac = localStorage.getItem('deviceMac');
            
            if (!savedMac) {
                const macArray = new Uint8Array(6);
                crypto.getRandomValues(macArray);
                savedMac = Array.from(macArray)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join(':')
                    .toUpperCase();
                localStorage.setItem('deviceMac', savedMac);
            }
            
            this.deviceMac = savedMac;
            this.deviceMacElement.textContent = this.deviceMac;
            console.log(`üì± MAC do dispositivo: ${this.deviceMac}`);
        }

        async checkAuthenticationStatus() {
            try {
                const savedAuth = localStorage.getItem('deviceAuth');
                if (savedAuth) {
                    const authData = JSON.parse(savedAuth);
                    this.deviceId = authData.deviceId;
                    
                    console.log('üîç Verificando autentica√ß√£o salva:', authData);
                    
                    try {
                        const response = await fetch(`${this.serverUrl}/api/client/device`, {
                            headers: {
                                'x-device-mac': this.deviceMac
                            }
                        });
                        
                        if (response.ok) {
                            this.deviceInfo = await response.json();
                            console.log('‚úÖ Dispositivo j√° autenticado e ativo:', this.deviceInfo);
                            this.startPlayback();
                            return;
                        } else if (response.status === 403) {
                            console.log('‚ùå Autentica√ß√£o salva n√£o √© mais v√°lida');
                            localStorage.removeItem('deviceAuth');
                        }
                    } catch (error) {
                        console.error('Erro ao verificar dispositivo:', error);
                    }
                }
                
                this.showAuthScreen();
                
            } catch (error) {
                console.error('‚ùå Erro ao verificar autentica√ß√£o:', error);
                this.showAuthScreen();
            }
        }

        startCodeGeneration() {
            this.generateNewAuthCode();
            
            this.codeGenerationInterval = setInterval(() => {
                this.generateNewAuthCode();
            }, 5 * 60 * 1000);
        }

        generateNewAuthCode() {
            this.authCode = Math.floor(100000 + Math.random() * 900000).toString();
            this.codeExpiry = new Date(Date.now() + 5 * 60 * 1000);
            
            this.generatedAuthCode.textContent = this.authCode;
            this.updateCodeExpiryDisplay();
            
            console.log(`üîê Novo c√≥digo gerado: ${this.authCode}`);
            
            this.registerAuthCodeWithServer();
        }

        updateCodeExpiryDisplay() {
            const now = new Date();
            const timeLeft = this.codeExpiry - now;
            
            if (timeLeft <= 0) {
                this.codeExpiryElement.textContent = 'C√≥digo expirado - gerando novo...';
                return;
            }
            
            const minutes = Math.floor(timeLeft / (60 * 1000));
            const seconds = Math.floor((timeLeft % (60 * 1000)) / 1000);
            
            this.codeExpiryElement.textContent = `Expira em: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            setTimeout(() => this.updateCodeExpiryDisplay(), 1000);
        }

        async registerAuthCodeWithServer() {
            try {
                const response = await fetch(`${this.serverUrl}/api/devices/register-code`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        mac: this.deviceMac,
                        authCode: this.authCode,
                        expiry: this.codeExpiry.toISOString()
                    })
                });

                if (response.ok) {
                    console.log('‚úÖ C√≥digo registrado no servidor para MAC:', this.deviceMac);
                } else {
                    console.error('‚ùå Erro ao registrar c√≥digo no servidor');
                }
            } catch (error) {
                console.error('‚ùå Erro de conex√£o ao registrar c√≥digo:', error);
            }
        }

        connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}`;
            
            console.log(`üîó Conectando WebSocket: ${wsUrl}`);
            
            this.ws = new WebSocket(wsUrl);
            
            this.ws.onopen = () => {
                console.log('‚úÖ WebSocket conectado com sucesso');
                this.wsStatusElement.textContent = 'Conectado';
                this.wsStatusElement.style.color = '#27ae60';
                
                if (this.deviceId) {
                    this.ws.send(JSON.stringify({
                        type: 'register',
                        deviceId: this.deviceId,
                        mac: this.deviceMac,
                        timestamp: Date.now()
                    }));
                }
            };
            
            this.ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    console.log('üì® Mensagem WebSocket recebida:', data.type);
                    this.handleWebSocketMessage(data);
                } catch (error) {
                    console.error('‚ùå Erro ao processar mensagem WebSocket:', error);
                }
            };
            
            this.ws.onclose = (event) => {
                console.log(`üîå WebSocket desconectado: C√≥digo ${event.code}, Raz√£o: ${event.reason}`);
                this.wsStatusElement.textContent = 'Desconectado';
                this.wsStatusElement.style.color = '#e74c3c';
                
                setTimeout(() => {
                    this.connectWebSocket();
                }, 5000);
            };
            
            this.ws.onerror = (error) => {
                console.error('‚ùå Erro WebSocket:', error);
                this.wsStatusElement.textContent = 'Erro';
                this.wsStatusElement.style.color = '#e74c3c';
            };
        }

        handleWebSocketMessage(data) {
            console.log('üì® Mensagem WebSocket:', data.type, data);
            
            switch(data.type) {
                case 'sync_command':
                    console.log('üîÑ COMANDO DE SINCRONIZA√á√ÉO RECEBIDO', data);
                    this.handleSyncCommand(data);
                    break;
                case 'announcement':
                    console.log('üì¢ Pronunciamento recebido:', data);
                    this.handleAnnouncement(data);
                    break;
                case 'announcement_cancelled':
                    console.log('‚ùå Pronunciamento cancelado:', data);
                    this.handleAnnouncementCancelled(data);
                    break;
                case 'send_preview':
                    console.log('üì∏ Preview solicitado');
                    this.sendCurrentMedia();
                    break;
                case 'device_disconnected':
                    console.log('üîå Dispositivo desconectado pelo administrador');
                    this.handleDeviceDisconnected(data);
                    break;
            }
        }

        // CORRIGIDA: Sincroniza√ß√£o que respeita o estado da playlist
        handleSyncCommand(data) {
            console.log('üîÑ Processando sincroniza√ß√£o da playlist:', data);
            
            this.clearTimers();
            this.stopAllMedia();
            
            // ARMAZENAR informa√ß√µes de sincroniza√ß√£o
            this.playlistSyncInfo = {
                currentMediaIndex: data.currentMediaIndex || 0,
                mediaStartTime: new Date(data.mediaStartTime),
                elapsedTime: data.elapsedTime || 0,
                remainingTime: data.remainingTime || 0,
                mediaDuration: data.mediaDuration || 0
            };
            
            console.log('üìä Estado da playlist recebido:', {
                mediaIndex: this.playlistSyncInfo.currentMediaIndex,
                elapsedTime: Math.round(this.playlistSyncInfo.elapsedTime / 1000) + 's',
                remainingTime: Math.round(this.playlistSyncInfo.remainingTime / 1000) + 's',
                mediaDuration: Math.round(this.playlistSyncInfo.mediaDuration / 1000) + 's'
            });
            
            // VERIFICAR se temos m√≠dias carregadas
            if (this.mediaList.length > 0) {
                this.applyPlaylistSync();
            } else {
                console.log('‚è≥ Aguardando carregamento das m√≠dias para aplicar sincroniza√ß√£o...');
            }
            
            this.showSyncNotification();
        }

         // CORRE√á√ÉO: Aplicar sincroniza√ß√£o
        applyPlaylistSync() {
            if (!this.playlistSyncInfo || this.mediaList.length === 0) {
                console.log('‚ùå Informa√ß√µes de sincroniza√ß√£o incompletas');
                this.playNextMedia();
                return;
            }
            
            const syncInfo = this.playlistSyncInfo;
            const targetMediaIndex = syncInfo.currentMediaIndex;
            
            // VALIDAR √≠ndice da m√≠dia
            if (targetMediaIndex >= this.mediaList.length) {
                console.log('‚ùå √çndice de m√≠dia inv√°lido, usando √≠ndice 0');
                this.currentMediaIndex = 0;
                this.playNextMedia();
                return;
            }
            
            const targetMedia = this.mediaList[targetMediaIndex];
            
            console.log(`üéØ Sincronizando para m√≠dia: ${targetMedia.originalName} (√≠ndice: ${targetMediaIndex})`);
            console.log(`‚è±Ô∏è ${Math.round(syncInfo.elapsedTime/1000)}s decorridos, ${Math.round(syncInfo.remainingTime/1000)}s restantes`);
            
            // SEMPRE trocar para a m√≠dia especificada pela playlist
            // N√£o verificar se j√° est√° na mesma m√≠dia - a playlist √© a verdade absoluta
            console.log('üîÑ For√ßando mudan√ßa para m√≠dia da playlist');
            this.playMediaWithSync(targetMediaIndex, syncInfo.elapsedTime, syncInfo.remainingTime, syncInfo.mediaDuration);
        }

        // CORRIGIDA: Atualizar timing da m√≠dia atual
        updateCurrentMediaTiming(elapsedTime, remainingTime, mediaDuration) {
            console.log(`‚è∞ Atualizando timing: ${Math.round(elapsedTime/1000)}s decorridos, ${Math.round(remainingTime/1000)}s restantes de ${Math.round(mediaDuration/1000)}s totais`);
            
            this.clearTimers();
            
            const remainingSeconds = Math.round(remainingTime / 1000);
            const totalSeconds = Math.round(mediaDuration / 1000);
            
            this.mediaTimeElement.textContent = `${remainingSeconds}s/${totalSeconds}s`;
            this.startCountdown(remainingTime);
            
            // CONFIGURAR timeout para pr√≥xima m√≠dia
            this.currentTimeout = setTimeout(() => {
                console.log('‚è∞ Timer da m√≠dia atual finalizado, indo para pr√≥xima...');
                this.playNextMedia();
            }, remainingTime);
            
            // APLICAR seek em v√≠deos se necess√°rio
            if (this.currentMedia && this.currentMedia.type === 'video' && !this.currentMedia.isExternal) {
                this.applyVideoSeek(elapsedTime);
            }
            
            this.sendCurrentMedia();
        }

        // CORRE√á√ÉO: Reproduzir m√≠dia espec√≠fica com sincroniza√ß√£o
        playMediaWithSync(mediaIndex, elapsedTime, remainingTime, mediaDuration) {
            if (mediaIndex >= this.mediaList.length) {
                console.log('‚ùå √çndice de m√≠dia inv√°lido, usando √≠ndice 0');
                mediaIndex = 0;
            }
            
            // CORRE√á√ÉO: Atualizar o √≠ndice atual para a m√≠dia sincronizada
            this.currentMediaIndex = mediaIndex;
            const media = this.mediaList[mediaIndex];
            
            console.log(`üé¨ Reproduzindo m√≠dia sincronizada: ${media.originalName} (√≠ndice: ${mediaIndex})`);
            console.log(`‚è±Ô∏è ${Math.round(elapsedTime/1000)}s decorridos, ${Math.round(remainingTime/1000)}s restantes de ${Math.round(mediaDuration/1000)}s totais`);
            
            this.currentMedia = media;
            this.stopAllMedia();
            
            const remainingSeconds = Math.round(remainingTime / 1000);
            const totalSeconds = Math.round(mediaDuration / 1000);
            
            this.currentMediaElement.textContent = media.originalName;
            this.mediaTimeElement.textContent = `${remainingSeconds}s/${totalSeconds}s`;
            this.debugInfo.textContent = `Sincronizado: ${media.originalName} (${remainingSeconds}s)`;
            
            // CONFIGURAR timeout para pr√≥xima m√≠dia
            this.clearTimers();
            this.currentTimeout = setTimeout(() => {
                console.log('‚è∞ Timer da m√≠dia sincronizada finalizado, indo para pr√≥xima...');
                
                // CORRE√á√ÉO: Calcular pr√≥ximo √≠ndice corretamente
                const nextIndex = (this.currentMediaIndex + 1) % this.mediaList.length;
                console.log(`üìä Pr√≥ximo √≠ndice ap√≥s sincroniza√ß√£o: ${nextIndex}`);
                this.currentMediaIndex = nextIndex;
                this.playNextMedia();
            }, remainingTime);
            
            this.startCountdown(remainingTime);
            this.sendCurrentMedia();
            
            // REPRODUZIR m√≠dia com seek
            this.playMediaByType(media, elapsedTime);
            
            // DEBUG: Log do estado ap√≥s sincroniza√ß√£o
            console.log(`üîç DEBUG SYNCMEDIA: √çndice definido: ${this.currentMediaIndex}, Pr√≥xima m√≠dia ser√°: ${(this.currentMediaIndex + 1) % this.mediaList.length}`);
        }

        // NOVO: M√©todo para debug - verificar estado da sincroniza√ß√£o
        debugSyncState() {
            console.log('üêõ DEBUG - Estado da Sincroniza√ß√£o:');
            console.log('üìä Playlist Sync Info:', this.playlistSyncInfo);
            console.log('üé¨ M√≠dia Atual:', this.currentMedia?.originalName);
            console.log('üìà √çndice Atual:', this.currentMediaIndex);
            console.log('üìã Total de M√≠dias:', this.mediaList.length);
            console.log('‚è∞ Timeout Ativo:', !!this.currentTimeout);
            console.log('üîí Playback Lock:', this.playbackLock);
        }

        // CORRIGIDA: Reproduzir m√≠dia considerando tempo decorrido
        playMediaByType(media, elapsedTime = 0) {
            const totalDuration = (media.displayTime || 10) * 1000;
            const seekTime = elapsedTime > 0 ? elapsedTime : 0;
            
            console.log(`üé¨ Reproduzindo: ${media.originalName}, seek: ${Math.round(seekTime/1000)}s`);
            
            switch(media.mediaType) {
                case 'upload':
                    if (media.type === 'image') {
                        this.playUploadedImage(media);
                    } else {
                        this.playUploadedVideo(media, seekTime);
                    }
                    break;
                case 'youtube':
                    this.playYouTube(media, seekTime);
                    break;
                case 'website':
                    this.playWebsite(media);
                    break;
                default:
                    console.warn('Tipo de m√≠dia n√£o suportado:', media.mediaType);
                    setTimeout(() => this.playNextMedia(), 2000);
            }
        }

        applyVideoSeek(elapsedTime) {
            if (this.videoDisplay && this.videoDisplay.readyState >= 2) {
                const seekSeconds = elapsedTime / 1000;
                if (seekSeconds < this.videoDisplay.duration) {
                    this.videoDisplay.currentTime = seekSeconds;
                    console.log(`‚è© Video seek aplicado: ${seekSeconds}s`);
                }
            }
        }

        // CORRE√á√ÉO: Buscar informa√ß√µes de sincroniza√ß√£o da playlist ao conectar
        async fetchPlaylistSyncInfo() {
            if (!this.deviceInfo || !this.deviceInfo.playlistId) {
                console.log('‚ÑπÔ∏è Dispositivo n√£o tem playlist espec√≠fica');
                return null;
            }
            
            try {
                console.log(`üîç Buscando informa√ß√µes de sincroniza√ß√£o para playlist: ${this.deviceInfo.playlistId}`);
                
                // CORRE√á√ÉO: N√£o enviar headers de autentica√ß√£o para esta rota
                const response = await fetch(`${this.serverUrl}/api/playlists/${this.deviceInfo.playlistId}/sync-info`);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('üìä Informa√ß√µes de sincroniza√ß√£o da playlist:', data.currentState);
                    return data.currentState;
                } else {
                    console.log('‚ùå N√£o foi poss√≠vel obter informa√ß√µes de sincroniza√ß√£o');
                    return null;
                }
            } catch (error) {
                console.error('‚ùå Erro ao buscar informa√ß√µes de sincroniza√ß√£o:', error);
                return null;
            }
        }

        showAuthScreen() {
            console.log('üéØ Mostrando tela de autentica√ß√£o...');
            this.authScreen.classList.remove('hidden');
            this.connectionError.classList.add('hidden');
            this.statusOverlay.classList.add('hidden');
            this.deviceStatusElement.textContent = 'Aguardando autentica√ß√£o';
            this.hideLoading();
        }

        hideAuthScreen() {
            console.log('üéØ Ocultando tela de autentica√ß√£o...');
            this.authScreen.classList.add('hidden');
            this.authError.style.display = 'none';
            this.hideLoading();
            
            if (this.codeGenerationInterval) {
                clearInterval(this.codeGenerationInterval);
                this.codeGenerationInterval = null;
            }
        }

        async startPlayback() {
            console.log('üöÄ Iniciando playback para dispositivo:', this.deviceInfo);
            
            this.hideAuthScreen();
            this.connectionError.classList.add('hidden');
            this.statusOverlay.classList.remove('hidden');
            this.debugPanel.classList.remove('hidden');
            
            this.deviceNameElement.textContent = this.deviceInfo.name;
            this.debugInfo.textContent = `Conectado: ${this.deviceInfo.name}`;
            this.deviceStatusElement.textContent = 'Autenticado';
            
            if (this.activationInterval) {
                clearInterval(this.activationInterval);
                this.activationInterval = null;
            }
            
            if (this.codeGenerationInterval) {
                clearInterval(this.codeGenerationInterval);
                this.codeGenerationInterval = null;
            }
            
            // PRIMEIRO buscar informa√ß√µes de sincroniza√ß√£o da playlist
            const playlistSyncInfo = await this.fetchPlaylistSyncInfo();
            
            if (playlistSyncInfo) {
                console.log('üéØ Usando sincroniza√ß√£o da playlist');
                this.playlistSyncInfo = playlistSyncInfo;
            } else {
                console.log('‚ÑπÔ∏è Iniciando reprodu√ß√£o normal');
            }
            
            // DEPOIS carregar m√≠dias
            await this.loadMediaList();
            this.connectWebSocket();
        }

        showErrorScreen(message) {
            console.log('‚ùå Mostrando tela de erro:', message);
            this.errorMessage.textContent = message;
            this.connectionError.classList.remove('hidden');
            this.statusOverlay.classList.add('hidden');
            this.authScreen.classList.add('hidden');
            this.hideLoading();
            this.clearTimers();
            this.stopAllMedia();
        }

        playUploadedImage(media) {
            this.showLoading(`Carregando imagem: ${media.originalName}`);
            
            this.mediaDisplay.onload = () => {
                console.log('‚úÖ Imagem carregada');
                this.hideLoading();
                this.mediaDisplay.classList.remove('hidden');
            };
            
            this.mediaDisplay.onerror = () => {
                console.error('‚ùå Erro ao carregar imagem');
                this.hideLoading();
                setTimeout(() => this.playNextMedia(), 2000);
            };
            
            this.mediaDisplay.src = `${this.serverUrl}${media.path}?t=${Date.now()}`;
        }

        playUploadedVideo(media, seekTime = 0) {
            this.showLoading(`Carregando v√≠deo: ${media.originalName}`);
            
            // CORRE√á√ÉO: Lidar com autoplay bloqueado
            const handlePlay = () => {
                console.log('‚úÖ V√≠deo carregado e pronto para reprodu√ß√£o');
                this.hideLoading();
                this.videoDisplay.classList.remove('hidden');
                
                if (seekTime > 0) {
                    const seekSeconds = seekTime / 1000;
                    this.videoDisplay.currentTime = Math.min(seekSeconds, this.videoDisplay.duration - 1);
                    console.log(`‚è© Video seek para: ${seekSeconds}s`);
                }
                
                // TENTAR reproduzir, mas n√£o falhar se bloqueado
                this.videoDisplay.play().catch(e => {
                    console.log('‚ö†Ô∏è Autoplay bloqueado, aguardando intera√ß√£o ou reproduzindo sem √°udio');
                    // N√£o fazer nada - o v√≠deo pode ser reproduzido sem √°udio
                });
            };
            
            this.videoDisplay.onloadeddata = handlePlay;
            this.videoDisplay.onerror = () => {
                console.error('‚ùå Erro ao carregar v√≠deo');
                this.hideLoading();
                setTimeout(() => this.playNextMedia(), 2000);
            };
            
            this.videoDisplay.onended = () => {
                console.log('‚è≠Ô∏è V√≠deo finalizado');
                this.playNextMedia();
            };
            
            this.videoDisplay.src = `${this.serverUrl}${media.path}?t=${Date.now()}`;
            this.videoDisplay.muted = true; // Mutar para evitar problemas de autoplay
            this.videoDisplay.playsInline = true; // Importante para iOS
        }

        playYouTube(media, seekTime = 0) {
            this.showLoading(`Carregando YouTube: ${media.originalName}`);
            
            const videoId = this.extractYouTubeId(media.path);
            if (!videoId) {
                console.error('‚ùå URL do YouTube inv√°lida');
                this.hideLoading();
                setTimeout(() => this.playNextMedia(), 2000);
                return;
            }
            
            let startParam = '';
            if (seekTime > 0) {
                const startSeconds = Math.floor(seekTime / 1000);
                startParam = `&start=${startSeconds}`;
                console.log(`‚è© YouTube start em: ${startSeconds}s`);
            }
            
            const embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1&controls=0&modestbranding=1&rel=0&enablejsapi=1${startParam}`;
            
            this.youtubeDisplay.onload = () => {
                console.log('‚úÖ YouTube carregado');
                this.hideLoading();
                this.youtubeDisplay.classList.remove('hidden');
            };
            
            this.youtubeDisplay.onerror = () => {
                console.error('‚ùå Erro ao carregar YouTube');
                this.hideLoading();
                setTimeout(() => this.playNextMedia(), 2000);
            };
            
            this.youtubeDisplay.src = embedUrl;
        }

        playWebsite(media) {
            this.showLoading(`Carregando site: ${media.originalName}`);
            
            this.webDisplay.onload = () => {
                console.log('‚úÖ Site carregado');
                this.hideLoading();
                this.webDisplay.classList.remove('hidden');
            };
            
            this.webDisplay.onerror = () => {
                console.error('‚ùå Erro ao carregar site');
                this.hideLoading();
                setTimeout(() => this.playNextMedia(), 2000);
            };
            
            this.webDisplay.src = media.path;
        }

        stopAllMedia() {
            this.mediaDisplay.classList.add('hidden');
            this.videoDisplay.classList.add('hidden');
            this.youtubeDisplay.classList.add('hidden');
            this.webDisplay.classList.add('hidden');
            
            if (this.videoDisplay) {
                this.videoDisplay.pause();
                this.videoDisplay.currentTime = 0;
            }
        }

        clearTimers() {
            if (this.currentTimeout) {
                clearTimeout(this.currentTimeout);
                this.currentTimeout = null;
            }
            
            if (this.currentCountdown) {
                clearInterval(this.currentCountdown);
                this.currentCountdown = null;
            }
            
            this.countdownElement.classList.add('hidden');
        }

        extractYouTubeId(url) {
            const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
            const match = url.match(regex);
            return match ? match[1] : null;
        }

        startCountdown(duration) {
            this.countdownElement.classList.remove('hidden');
            let timeLeft = duration / 1000;
            this.countdownTimer.textContent = Math.round(timeLeft);
            
            if (this.currentCountdown) {
                clearInterval(this.currentCountdown);
            }
            
            this.currentCountdown = setInterval(() => {
                timeLeft--;
                this.countdownTimer.textContent = Math.round(timeLeft);
                
                if (timeLeft <= 0) {
                    clearInterval(this.currentCountdown);
                    this.countdownElement.classList.add('hidden');
                }
            }, 1000);
        }

        showLoading(message) {
            this.loadingElement.textContent = message;
            this.loadingElement.classList.remove('hidden');
        }
        
        hideLoading() {
            this.loadingElement.classList.add('hidden');
        }

        sendCurrentMedia() {
            const now = Date.now();
            if (now - this.lastMediaUpdate < 10000) {
                return;
            }
            
            if (this.ws && this.ws.readyState === WebSocket.OPEN && this.currentMedia) {
                const mediaInfo = {
                    type: 'current_media',
                    deviceId: this.deviceId,
                    media: this.currentMedia,
                    currentMediaIndex: this.currentMediaIndex,
                    timestamp: new Date()
                };
                
                this.ws.send(JSON.stringify(mediaInfo));
                this.lastMediaUpdate = now;
            }
        }

 // NOVO: M√©todo para verificar e corrigir estado do √≠ndice
        validateMediaIndex() {
            if (this.currentMediaIndex >= this.mediaList.length) {
                console.warn('‚ö†Ô∏è √çndice de m√≠dia inv√°lido, corrigindo para 0');
                this.currentMediaIndex = 0;
            }
            
            console.log(`üîç VALIDA√á√ÉO: √çndice atual: ${this.currentMediaIndex}, Total de m√≠dias: ${this.mediaList.length}`);
            return this.currentMediaIndex;
        }

        // ATUALIZAR: Carregar m√≠dias com valida√ß√£o de √≠ndice
        async loadMediaList() {
            if (this.isLoadingMedia) {
                return;
            }
            
            this.isLoadingMedia = true;
            
            try {
                this.showLoading('Carregando conte√∫do...');
                
                const response = await fetch(`${this.serverUrl}/api/client/media`, {
                    headers: {
                        'x-device-mac': this.deviceMac
                    }
                });
                
                if (response.ok) {
                    this.mediaList = await response.json();
                    console.log(`üìã ${this.mediaList.length} m√≠dia(s) carregada(s)`);
                    
                    if (this.mediaList.length > 0) {
                        this.hideLoading();
                        
                        // CORRE√á√ÉO: Validar √≠ndice antes de usar
                        this.validateMediaIndex();
                        
                        // SE temos sincroniza√ß√£o da playlist, aplicar
                        if (this.playlistSyncInfo) {
                            console.log('üéØ Aplicando sincroniza√ß√£o da playlist ap√≥s carregamento');
                            this.applyPlaylistSync();
                        } else {
                            // CORRE√á√ÉO: Iniciar reprodu√ß√£o com √≠ndice validado
                            console.log(`üé¨ Iniciando reprodu√ß√£o normal do √≠ndice: ${this.currentMediaIndex}`);
                            this.playNextMedia();
                        }
                    } else {
                        this.showLoading('‚ö†Ô∏è Nenhum conte√∫do dispon√≠vel');
                    }
                } else {
                    throw new Error('Erro ao carregar conte√∫do');
                }
            } catch (error) {
                console.error('‚ùå Erro ao carregar m√≠dias:', error);
                this.showErrorScreen('Erro ao carregar conte√∫do');
            } finally {
                this.isLoadingMedia = false;
            }
        }

        // CORRE√á√ÉO: Reproduzir pr√≥xima m√≠dia com controle correto de √≠ndice
        playNextMedia() {
            if (this.playbackLock) {
                console.log('‚è∏Ô∏è  Playback bloqueado, aguardando...');
                return;
            }
            
            if (this.mediaList.length === 0) {
                console.log('‚ùå Nenhuma m√≠dia para reproduzir');
                return;
            }
            
            this.clearTimers();
            
            // CORRE√á√ÉO: Verificar se chegou ao final da playlist
            if (this.currentMediaIndex >= this.mediaList.length) {
                this.currentMediaIndex = 0;
                console.log('üîÑ Fim da playlist, reiniciando do √≠ndice 0...');
            }
            
            const media = this.mediaList[this.currentMediaIndex];
            console.log(`üé¨ Reproduzindo m√≠dia ${this.currentMediaIndex + 1}/${this.mediaList.length}: ${media.originalName}`);
            
            // CORRE√á√ÉO: Reproduzir a m√≠dia atual ANTES de incrementar o √≠ndice
            this.playMedia(media);
            
            // CORRE√á√ÉO: Incrementar √≠ndice AP√ìS reproduzir a m√≠dia atual
            this.currentMediaIndex = (this.currentMediaIndex + 1) % this.mediaList.length;
            console.log(`üìä Pr√≥ximo √≠ndice ser√°: ${this.currentMediaIndex}`);
        }

        // CORRE√á√ÉO: Reproduzir m√≠dia normalmente
        playMedia(media, isAnnouncement = false) {
            if (this.playbackLock && this.currentMedia && this.currentMedia.id === media.id) {
                console.log('‚è∏Ô∏è  M√≠dia j√° est√° sendo reproduzida, ignorando...');
                return;
            }
            
            this.currentMedia = media;
            this.stopAllMedia();
            this.playbackLock = true;
            
            this.currentMediaElement.textContent = media.originalName;
            
            const displayTime = (media.displayTime || 10) * 1000;
            const displaySeconds = Math.round(displayTime / 1000);
            
            this.mediaTimeElement.textContent = `${displaySeconds}s/${displaySeconds}s`;
            this.debugInfo.textContent = `Reproduzindo: ${media.originalName} ${isAnnouncement ? '(Anunciamento)' : ''}`;
            
            this.mediaStartTime = new Date();
            
            this.startCountdown(displayTime);
            
            if (this.currentTimeout) {
                clearTimeout(this.currentTimeout);
            }
            
            this.currentTimeout = setTimeout(() => {
                console.log('‚è∞ Timer da m√≠dia finalizado, indo para pr√≥xima...');
                this.playbackLock = false;
                if (!isAnnouncement) {
                    this.playNextMedia();
                }
            }, displayTime);
            
            this.sendCurrentMedia();
            this.playMediaByType(media, 0);
            
            // DEBUG: Log do estado atual
            console.log(`üîç DEBUG PLAYMEDIA: √çndice atual: ${this.currentMediaIndex}, M√≠dia: ${media.originalName}`);
        }

        handleAnnouncement(data) {
            console.log('üì¢ Anunciamento recebido:', data.announcement.name);
            
            this.clearTimers();
            this.stopAllMedia();
            
            this.playMedia(data.media, true);
            
            setTimeout(() => {
                if (this.playlistSyncInfo) {
                    this.applyPlaylistSync();
                } else {
                    this.loadMediaList();
                }
            }, data.announcement.displayTime * 1000);
        }
        
        handleAnnouncementCancelled(data) {
            console.log('üõë Anunciamento cancelado');
            if (this.playlistSyncInfo) {
                this.applyPlaylistSync();
            } else {
                this.loadMediaList();
            }
        }
        
        handleDeviceDisconnected(data) {
            console.log('üîå Dispositivo desconectado pelo administrador');
            
            localStorage.removeItem('deviceAuth');
            this.deviceId = null;
            this.deviceInfo = null;
            this.playlistSyncInfo = null;
            
            this.clearTimers();
            this.stopAllMedia();
            
            this.startCodeGeneration();
            this.startActivationPolling();
            this.showAuthScreen();
            
            if (this.ws) {
                this.ws.close();
            }
        }
        
        showSyncNotification() {
            this.syncNotification.classList.remove('hidden');
            setTimeout(() => {
                this.syncNotification.classList.add('hidden');
            }, 3000);
        }
    }
    
    let mediaPlayer;
    
    document.addEventListener('DOMContentLoaded', () => {
        mediaPlayer = new MediaPlayer();
    });

    document.addEventListener('dragstart', (e) => e.preventDefault());
    
    window.addEventListener('error', (e) => {
        console.error('üö® Erro global:', e.error);
    });
</script>
</body>
</html>